
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Anamnesis
 * 
 */
export type Anamnesis = $Result.DefaultSelection<Prisma.$AnamnesisPayload>
/**
 * Model Athlete
 * 
 */
export type Athlete = $Result.DefaultSelection<Prisma.$AthletePayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Trainer
 * 
 */
export type Trainer = $Result.DefaultSelection<Prisma.$TrainerPayload>
/**
 * Model BodyValuation
 * 
 */
export type BodyValuation = $Result.DefaultSelection<Prisma.$BodyValuationPayload>
/**
 * Model Exercise
 * ////////////////////////////////
 */
export type Exercise = $Result.DefaultSelection<Prisma.$ExercisePayload>
/**
 * Model FlexEvaluation
 * 
 */
export type FlexEvaluation = $Result.DefaultSelection<Prisma.$FlexEvaluationPayload>
/**
 * Model MethodExercise
 * 
 */
export type MethodExercise = $Result.DefaultSelection<Prisma.$MethodExercisePayload>
/**
 * Model StatusPhoto
 * 
 */
export type StatusPhoto = $Result.DefaultSelection<Prisma.$StatusPhotoPayload>
/**
 * Model Target
 * 
 */
export type Target = $Result.DefaultSelection<Prisma.$TargetPayload>
/**
 * Model Training
 * 
 */
export type Training = $Result.DefaultSelection<Prisma.$TrainingPayload>
/**
 * Model TrainingEvolution
 * 
 */
export type TrainingEvolution = $Result.DefaultSelection<Prisma.$TrainingEvolutionPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Anamneses
 * const anamneses = await prisma.anamnesis.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Anamneses
   * const anamneses = await prisma.anamnesis.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.anamnesis`: Exposes CRUD operations for the **Anamnesis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Anamneses
    * const anamneses = await prisma.anamnesis.findMany()
    * ```
    */
  get anamnesis(): Prisma.AnamnesisDelegate<ExtArgs>;

  /**
   * `prisma.athlete`: Exposes CRUD operations for the **Athlete** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Athletes
    * const athletes = await prisma.athlete.findMany()
    * ```
    */
  get athlete(): Prisma.AthleteDelegate<ExtArgs>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs>;

  /**
   * `prisma.trainer`: Exposes CRUD operations for the **Trainer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trainers
    * const trainers = await prisma.trainer.findMany()
    * ```
    */
  get trainer(): Prisma.TrainerDelegate<ExtArgs>;

  /**
   * `prisma.bodyValuation`: Exposes CRUD operations for the **BodyValuation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BodyValuations
    * const bodyValuations = await prisma.bodyValuation.findMany()
    * ```
    */
  get bodyValuation(): Prisma.BodyValuationDelegate<ExtArgs>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<ExtArgs>;

  /**
   * `prisma.flexEvaluation`: Exposes CRUD operations for the **FlexEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlexEvaluations
    * const flexEvaluations = await prisma.flexEvaluation.findMany()
    * ```
    */
  get flexEvaluation(): Prisma.FlexEvaluationDelegate<ExtArgs>;

  /**
   * `prisma.methodExercise`: Exposes CRUD operations for the **MethodExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MethodExercises
    * const methodExercises = await prisma.methodExercise.findMany()
    * ```
    */
  get methodExercise(): Prisma.MethodExerciseDelegate<ExtArgs>;

  /**
   * `prisma.statusPhoto`: Exposes CRUD operations for the **StatusPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatusPhotos
    * const statusPhotos = await prisma.statusPhoto.findMany()
    * ```
    */
  get statusPhoto(): Prisma.StatusPhotoDelegate<ExtArgs>;

  /**
   * `prisma.target`: Exposes CRUD operations for the **Target** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Targets
    * const targets = await prisma.target.findMany()
    * ```
    */
  get target(): Prisma.TargetDelegate<ExtArgs>;

  /**
   * `prisma.training`: Exposes CRUD operations for the **Training** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trainings
    * const trainings = await prisma.training.findMany()
    * ```
    */
  get training(): Prisma.TrainingDelegate<ExtArgs>;

  /**
   * `prisma.trainingEvolution`: Exposes CRUD operations for the **TrainingEvolution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingEvolutions
    * const trainingEvolutions = await prisma.trainingEvolution.findMany()
    * ```
    */
  get trainingEvolution(): Prisma.TrainingEvolutionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.1.0
   * Query Engine version: a9b7003df90aa623086e4d6f4e43c72468e6339b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Anamnesis: 'Anamnesis',
    Athlete: 'Athlete',
    Address: 'Address',
    Trainer: 'Trainer',
    BodyValuation: 'BodyValuation',
    Exercise: 'Exercise',
    FlexEvaluation: 'FlexEvaluation',
    MethodExercise: 'MethodExercise',
    StatusPhoto: 'StatusPhoto',
    Target: 'Target',
    Training: 'Training',
    TrainingEvolution: 'TrainingEvolution'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'anamnesis' | 'athlete' | 'address' | 'trainer' | 'bodyValuation' | 'exercise' | 'flexEvaluation' | 'methodExercise' | 'statusPhoto' | 'target' | 'training' | 'trainingEvolution'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Anamnesis: {
        payload: Prisma.$AnamnesisPayload<ExtArgs>
        fields: Prisma.AnamnesisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnamnesisFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnamnesisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnamnesisFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnamnesisPayload>
          }
          findFirst: {
            args: Prisma.AnamnesisFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnamnesisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnamnesisFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnamnesisPayload>
          }
          findMany: {
            args: Prisma.AnamnesisFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnamnesisPayload>[]
          }
          create: {
            args: Prisma.AnamnesisCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnamnesisPayload>
          }
          createMany: {
            args: Prisma.AnamnesisCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AnamnesisDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnamnesisPayload>
          }
          update: {
            args: Prisma.AnamnesisUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnamnesisPayload>
          }
          deleteMany: {
            args: Prisma.AnamnesisDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AnamnesisUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AnamnesisUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnamnesisPayload>
          }
          aggregate: {
            args: Prisma.AnamnesisAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnamnesis>
          }
          groupBy: {
            args: Prisma.AnamnesisGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnamnesisGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnamnesisCountArgs<ExtArgs>,
            result: $Utils.Optional<AnamnesisCountAggregateOutputType> | number
          }
        }
      }
      Athlete: {
        payload: Prisma.$AthletePayload<ExtArgs>
        fields: Prisma.AthleteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AthleteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AthletePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AthleteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          findFirst: {
            args: Prisma.AthleteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AthletePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AthleteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          findMany: {
            args: Prisma.AthleteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>[]
          }
          create: {
            args: Prisma.AthleteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          createMany: {
            args: Prisma.AthleteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AthleteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          update: {
            args: Prisma.AthleteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          deleteMany: {
            args: Prisma.AthleteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AthleteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AthleteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AthletePayload>
          }
          aggregate: {
            args: Prisma.AthleteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAthlete>
          }
          groupBy: {
            args: Prisma.AthleteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AthleteGroupByOutputType>[]
          }
          count: {
            args: Prisma.AthleteCountArgs<ExtArgs>,
            result: $Utils.Optional<AthleteCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>,
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Trainer: {
        payload: Prisma.$TrainerPayload<ExtArgs>
        fields: Prisma.TrainerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainerPayload>
          }
          findFirst: {
            args: Prisma.TrainerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainerPayload>
          }
          findMany: {
            args: Prisma.TrainerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainerPayload>[]
          }
          create: {
            args: Prisma.TrainerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainerPayload>
          }
          createMany: {
            args: Prisma.TrainerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TrainerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainerPayload>
          }
          update: {
            args: Prisma.TrainerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainerPayload>
          }
          deleteMany: {
            args: Prisma.TrainerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TrainerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TrainerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainerPayload>
          }
          aggregate: {
            args: Prisma.TrainerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTrainer>
          }
          groupBy: {
            args: Prisma.TrainerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrainerGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainerCountArgs<ExtArgs>,
            result: $Utils.Optional<TrainerCountAggregateOutputType> | number
          }
        }
      }
      BodyValuation: {
        payload: Prisma.$BodyValuationPayload<ExtArgs>
        fields: Prisma.BodyValuationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BodyValuationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodyValuationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BodyValuationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodyValuationPayload>
          }
          findFirst: {
            args: Prisma.BodyValuationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodyValuationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BodyValuationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodyValuationPayload>
          }
          findMany: {
            args: Prisma.BodyValuationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodyValuationPayload>[]
          }
          create: {
            args: Prisma.BodyValuationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodyValuationPayload>
          }
          createMany: {
            args: Prisma.BodyValuationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BodyValuationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodyValuationPayload>
          }
          update: {
            args: Prisma.BodyValuationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodyValuationPayload>
          }
          deleteMany: {
            args: Prisma.BodyValuationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BodyValuationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BodyValuationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BodyValuationPayload>
          }
          aggregate: {
            args: Prisma.BodyValuationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBodyValuation>
          }
          groupBy: {
            args: Prisma.BodyValuationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BodyValuationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BodyValuationCountArgs<ExtArgs>,
            result: $Utils.Optional<BodyValuationCountAggregateOutputType> | number
          }
        }
      }
      Exercise: {
        payload: Prisma.$ExercisePayload<ExtArgs>
        fields: Prisma.ExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findFirst: {
            args: Prisma.ExerciseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findMany: {
            args: Prisma.ExerciseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          create: {
            args: Prisma.ExerciseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          createMany: {
            args: Prisma.ExerciseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ExerciseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          update: {
            args: Prisma.ExerciseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          deleteMany: {
            args: Prisma.ExerciseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ExerciseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          aggregate: {
            args: Prisma.ExerciseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExercise>
          }
          groupBy: {
            args: Prisma.ExerciseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseCountArgs<ExtArgs>,
            result: $Utils.Optional<ExerciseCountAggregateOutputType> | number
          }
        }
      }
      FlexEvaluation: {
        payload: Prisma.$FlexEvaluationPayload<ExtArgs>
        fields: Prisma.FlexEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlexEvaluationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FlexEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlexEvaluationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FlexEvaluationPayload>
          }
          findFirst: {
            args: Prisma.FlexEvaluationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FlexEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlexEvaluationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FlexEvaluationPayload>
          }
          findMany: {
            args: Prisma.FlexEvaluationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FlexEvaluationPayload>[]
          }
          create: {
            args: Prisma.FlexEvaluationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FlexEvaluationPayload>
          }
          createMany: {
            args: Prisma.FlexEvaluationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FlexEvaluationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FlexEvaluationPayload>
          }
          update: {
            args: Prisma.FlexEvaluationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FlexEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.FlexEvaluationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FlexEvaluationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FlexEvaluationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FlexEvaluationPayload>
          }
          aggregate: {
            args: Prisma.FlexEvaluationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFlexEvaluation>
          }
          groupBy: {
            args: Prisma.FlexEvaluationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FlexEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlexEvaluationCountArgs<ExtArgs>,
            result: $Utils.Optional<FlexEvaluationCountAggregateOutputType> | number
          }
        }
      }
      MethodExercise: {
        payload: Prisma.$MethodExercisePayload<ExtArgs>
        fields: Prisma.MethodExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MethodExerciseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MethodExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MethodExerciseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MethodExercisePayload>
          }
          findFirst: {
            args: Prisma.MethodExerciseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MethodExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MethodExerciseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MethodExercisePayload>
          }
          findMany: {
            args: Prisma.MethodExerciseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MethodExercisePayload>[]
          }
          create: {
            args: Prisma.MethodExerciseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MethodExercisePayload>
          }
          createMany: {
            args: Prisma.MethodExerciseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MethodExerciseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MethodExercisePayload>
          }
          update: {
            args: Prisma.MethodExerciseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MethodExercisePayload>
          }
          deleteMany: {
            args: Prisma.MethodExerciseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MethodExerciseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MethodExerciseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MethodExercisePayload>
          }
          aggregate: {
            args: Prisma.MethodExerciseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMethodExercise>
          }
          groupBy: {
            args: Prisma.MethodExerciseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MethodExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.MethodExerciseCountArgs<ExtArgs>,
            result: $Utils.Optional<MethodExerciseCountAggregateOutputType> | number
          }
        }
      }
      StatusPhoto: {
        payload: Prisma.$StatusPhotoPayload<ExtArgs>
        fields: Prisma.StatusPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatusPhotoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatusPhotoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPhotoPayload>
          }
          findFirst: {
            args: Prisma.StatusPhotoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatusPhotoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPhotoPayload>
          }
          findMany: {
            args: Prisma.StatusPhotoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPhotoPayload>[]
          }
          create: {
            args: Prisma.StatusPhotoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPhotoPayload>
          }
          createMany: {
            args: Prisma.StatusPhotoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StatusPhotoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPhotoPayload>
          }
          update: {
            args: Prisma.StatusPhotoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPhotoPayload>
          }
          deleteMany: {
            args: Prisma.StatusPhotoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StatusPhotoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StatusPhotoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StatusPhotoPayload>
          }
          aggregate: {
            args: Prisma.StatusPhotoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStatusPhoto>
          }
          groupBy: {
            args: Prisma.StatusPhotoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StatusPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatusPhotoCountArgs<ExtArgs>,
            result: $Utils.Optional<StatusPhotoCountAggregateOutputType> | number
          }
        }
      }
      Target: {
        payload: Prisma.$TargetPayload<ExtArgs>
        fields: Prisma.TargetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TargetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TargetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetPayload>
          }
          findFirst: {
            args: Prisma.TargetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TargetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetPayload>
          }
          findMany: {
            args: Prisma.TargetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetPayload>[]
          }
          create: {
            args: Prisma.TargetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetPayload>
          }
          createMany: {
            args: Prisma.TargetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TargetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetPayload>
          }
          update: {
            args: Prisma.TargetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetPayload>
          }
          deleteMany: {
            args: Prisma.TargetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TargetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TargetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetPayload>
          }
          aggregate: {
            args: Prisma.TargetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTarget>
          }
          groupBy: {
            args: Prisma.TargetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TargetGroupByOutputType>[]
          }
          count: {
            args: Prisma.TargetCountArgs<ExtArgs>,
            result: $Utils.Optional<TargetCountAggregateOutputType> | number
          }
        }
      }
      Training: {
        payload: Prisma.$TrainingPayload<ExtArgs>
        fields: Prisma.TrainingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          findFirst: {
            args: Prisma.TrainingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          findMany: {
            args: Prisma.TrainingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>[]
          }
          create: {
            args: Prisma.TrainingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          createMany: {
            args: Prisma.TrainingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TrainingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          update: {
            args: Prisma.TrainingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          deleteMany: {
            args: Prisma.TrainingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TrainingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          aggregate: {
            args: Prisma.TrainingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTraining>
          }
          groupBy: {
            args: Prisma.TrainingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrainingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingCountArgs<ExtArgs>,
            result: $Utils.Optional<TrainingCountAggregateOutputType> | number
          }
        }
      }
      TrainingEvolution: {
        payload: Prisma.$TrainingEvolutionPayload<ExtArgs>
        fields: Prisma.TrainingEvolutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingEvolutionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingEvolutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingEvolutionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingEvolutionPayload>
          }
          findFirst: {
            args: Prisma.TrainingEvolutionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingEvolutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingEvolutionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingEvolutionPayload>
          }
          findMany: {
            args: Prisma.TrainingEvolutionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingEvolutionPayload>[]
          }
          create: {
            args: Prisma.TrainingEvolutionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingEvolutionPayload>
          }
          createMany: {
            args: Prisma.TrainingEvolutionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TrainingEvolutionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingEvolutionPayload>
          }
          update: {
            args: Prisma.TrainingEvolutionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingEvolutionPayload>
          }
          deleteMany: {
            args: Prisma.TrainingEvolutionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingEvolutionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TrainingEvolutionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingEvolutionPayload>
          }
          aggregate: {
            args: Prisma.TrainingEvolutionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTrainingEvolution>
          }
          groupBy: {
            args: Prisma.TrainingEvolutionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrainingEvolutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingEvolutionCountArgs<ExtArgs>,
            result: $Utils.Optional<TrainingEvolutionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Anamnesis
   */

  export type AggregateAnamnesis = {
    _count: AnamnesisCountAggregateOutputType | null
    _min: AnamnesisMinAggregateOutputType | null
    _max: AnamnesisMaxAggregateOutputType | null
  }

  export type AnamnesisMinAggregateOutputType = {
    id: string | null
  }

  export type AnamnesisMaxAggregateOutputType = {
    id: string | null
  }

  export type AnamnesisCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type AnamnesisMinAggregateInputType = {
    id?: true
  }

  export type AnamnesisMaxAggregateInputType = {
    id?: true
  }

  export type AnamnesisCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type AnamnesisAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Anamnesis to aggregate.
     */
    where?: AnamnesisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anamneses to fetch.
     */
    orderBy?: AnamnesisOrderByWithRelationInput | AnamnesisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnamnesisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anamneses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anamneses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Anamneses
    **/
    _count?: true | AnamnesisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnamnesisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnamnesisMaxAggregateInputType
  }

  export type GetAnamnesisAggregateType<T extends AnamnesisAggregateArgs> = {
        [P in keyof T & keyof AggregateAnamnesis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnamnesis[P]>
      : GetScalarType<T[P], AggregateAnamnesis[P]>
  }




  export type AnamnesisGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AnamnesisWhereInput
    orderBy?: AnamnesisOrderByWithAggregationInput | AnamnesisOrderByWithAggregationInput[]
    by: AnamnesisScalarFieldEnum[] | AnamnesisScalarFieldEnum
    having?: AnamnesisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnamnesisCountAggregateInputType | true
    _min?: AnamnesisMinAggregateInputType
    _max?: AnamnesisMaxAggregateInputType
  }

  export type AnamnesisGroupByOutputType = {
    id: string
    _count: AnamnesisCountAggregateOutputType | null
    _min: AnamnesisMinAggregateOutputType | null
    _max: AnamnesisMaxAggregateOutputType | null
  }

  type GetAnamnesisGroupByPayload<T extends AnamnesisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnamnesisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnamnesisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnamnesisGroupByOutputType[P]>
            : GetScalarType<T[P], AnamnesisGroupByOutputType[P]>
        }
      >
    >


  export type AnamnesisSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["anamnesis"]>

  export type AnamnesisSelectScalar = {
    id?: boolean
  }


  export type $AnamnesisPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Anamnesis"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: string
    }, ExtArgs["result"]["anamnesis"]>
    composites: {}
  }


  type AnamnesisGetPayload<S extends boolean | null | undefined | AnamnesisDefaultArgs> = $Result.GetResult<Prisma.$AnamnesisPayload, S>

  type AnamnesisCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AnamnesisFindManyArgs, 'select' | 'include'> & {
      select?: AnamnesisCountAggregateInputType | true
    }

  export interface AnamnesisDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Anamnesis'], meta: { name: 'Anamnesis' } }
    /**
     * Find zero or one Anamnesis that matches the filter.
     * @param {AnamnesisFindUniqueArgs} args - Arguments to find a Anamnesis
     * @example
     * // Get one Anamnesis
     * const anamnesis = await prisma.anamnesis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnamnesisFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AnamnesisFindUniqueArgs<ExtArgs>>
    ): Prisma__AnamnesisClient<$Result.GetResult<Prisma.$AnamnesisPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Anamnesis that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AnamnesisFindUniqueOrThrowArgs} args - Arguments to find a Anamnesis
     * @example
     * // Get one Anamnesis
     * const anamnesis = await prisma.anamnesis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AnamnesisFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnamnesisFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnamnesisClient<$Result.GetResult<Prisma.$AnamnesisPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Anamnesis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnamnesisFindFirstArgs} args - Arguments to find a Anamnesis
     * @example
     * // Get one Anamnesis
     * const anamnesis = await prisma.anamnesis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnamnesisFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AnamnesisFindFirstArgs<ExtArgs>>
    ): Prisma__AnamnesisClient<$Result.GetResult<Prisma.$AnamnesisPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Anamnesis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnamnesisFindFirstOrThrowArgs} args - Arguments to find a Anamnesis
     * @example
     * // Get one Anamnesis
     * const anamnesis = await prisma.anamnesis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AnamnesisFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnamnesisFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnamnesisClient<$Result.GetResult<Prisma.$AnamnesisPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Anamneses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnamnesisFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Anamneses
     * const anamneses = await prisma.anamnesis.findMany()
     * 
     * // Get first 10 Anamneses
     * const anamneses = await prisma.anamnesis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anamnesisWithIdOnly = await prisma.anamnesis.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AnamnesisFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnamnesisFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnamnesisPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Anamnesis.
     * @param {AnamnesisCreateArgs} args - Arguments to create a Anamnesis.
     * @example
     * // Create one Anamnesis
     * const Anamnesis = await prisma.anamnesis.create({
     *   data: {
     *     // ... data to create a Anamnesis
     *   }
     * })
     * 
    **/
    create<T extends AnamnesisCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AnamnesisCreateArgs<ExtArgs>>
    ): Prisma__AnamnesisClient<$Result.GetResult<Prisma.$AnamnesisPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Anamneses.
     *     @param {AnamnesisCreateManyArgs} args - Arguments to create many Anamneses.
     *     @example
     *     // Create many Anamneses
     *     const anamnesis = await prisma.anamnesis.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AnamnesisCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnamnesisCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Anamnesis.
     * @param {AnamnesisDeleteArgs} args - Arguments to delete one Anamnesis.
     * @example
     * // Delete one Anamnesis
     * const Anamnesis = await prisma.anamnesis.delete({
     *   where: {
     *     // ... filter to delete one Anamnesis
     *   }
     * })
     * 
    **/
    delete<T extends AnamnesisDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AnamnesisDeleteArgs<ExtArgs>>
    ): Prisma__AnamnesisClient<$Result.GetResult<Prisma.$AnamnesisPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Anamnesis.
     * @param {AnamnesisUpdateArgs} args - Arguments to update one Anamnesis.
     * @example
     * // Update one Anamnesis
     * const anamnesis = await prisma.anamnesis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnamnesisUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AnamnesisUpdateArgs<ExtArgs>>
    ): Prisma__AnamnesisClient<$Result.GetResult<Prisma.$AnamnesisPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Anamneses.
     * @param {AnamnesisDeleteManyArgs} args - Arguments to filter Anamneses to delete.
     * @example
     * // Delete a few Anamneses
     * const { count } = await prisma.anamnesis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnamnesisDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnamnesisDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anamneses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnamnesisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Anamneses
     * const anamnesis = await prisma.anamnesis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnamnesisUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AnamnesisUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Anamnesis.
     * @param {AnamnesisUpsertArgs} args - Arguments to update or create a Anamnesis.
     * @example
     * // Update or create a Anamnesis
     * const anamnesis = await prisma.anamnesis.upsert({
     *   create: {
     *     // ... data to create a Anamnesis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Anamnesis we want to update
     *   }
     * })
    **/
    upsert<T extends AnamnesisUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AnamnesisUpsertArgs<ExtArgs>>
    ): Prisma__AnamnesisClient<$Result.GetResult<Prisma.$AnamnesisPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Anamneses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnamnesisCountArgs} args - Arguments to filter Anamneses to count.
     * @example
     * // Count the number of Anamneses
     * const count = await prisma.anamnesis.count({
     *   where: {
     *     // ... the filter for the Anamneses we want to count
     *   }
     * })
    **/
    count<T extends AnamnesisCountArgs>(
      args?: Subset<T, AnamnesisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnamnesisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Anamnesis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnamnesisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnamnesisAggregateArgs>(args: Subset<T, AnamnesisAggregateArgs>): Prisma.PrismaPromise<GetAnamnesisAggregateType<T>>

    /**
     * Group by Anamnesis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnamnesisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnamnesisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnamnesisGroupByArgs['orderBy'] }
        : { orderBy?: AnamnesisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnamnesisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnamnesisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Anamnesis model
   */
  readonly fields: AnamnesisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Anamnesis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnamnesisClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Anamnesis model
   */ 
  interface AnamnesisFieldRefs {
    readonly id: FieldRef<"Anamnesis", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Anamnesis findUnique
   */
  export type AnamnesisFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Filter, which Anamnesis to fetch.
     */
    where: AnamnesisWhereUniqueInput
  }


  /**
   * Anamnesis findUniqueOrThrow
   */
  export type AnamnesisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Filter, which Anamnesis to fetch.
     */
    where: AnamnesisWhereUniqueInput
  }


  /**
   * Anamnesis findFirst
   */
  export type AnamnesisFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Filter, which Anamnesis to fetch.
     */
    where?: AnamnesisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anamneses to fetch.
     */
    orderBy?: AnamnesisOrderByWithRelationInput | AnamnesisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anamneses.
     */
    cursor?: AnamnesisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anamneses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anamneses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anamneses.
     */
    distinct?: AnamnesisScalarFieldEnum | AnamnesisScalarFieldEnum[]
  }


  /**
   * Anamnesis findFirstOrThrow
   */
  export type AnamnesisFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Filter, which Anamnesis to fetch.
     */
    where?: AnamnesisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anamneses to fetch.
     */
    orderBy?: AnamnesisOrderByWithRelationInput | AnamnesisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anamneses.
     */
    cursor?: AnamnesisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anamneses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anamneses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anamneses.
     */
    distinct?: AnamnesisScalarFieldEnum | AnamnesisScalarFieldEnum[]
  }


  /**
   * Anamnesis findMany
   */
  export type AnamnesisFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Filter, which Anamneses to fetch.
     */
    where?: AnamnesisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anamneses to fetch.
     */
    orderBy?: AnamnesisOrderByWithRelationInput | AnamnesisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Anamneses.
     */
    cursor?: AnamnesisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anamneses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anamneses.
     */
    skip?: number
    distinct?: AnamnesisScalarFieldEnum | AnamnesisScalarFieldEnum[]
  }


  /**
   * Anamnesis create
   */
  export type AnamnesisCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * The data needed to create a Anamnesis.
     */
    data?: XOR<AnamnesisCreateInput, AnamnesisUncheckedCreateInput>
  }


  /**
   * Anamnesis createMany
   */
  export type AnamnesisCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Anamneses.
     */
    data: AnamnesisCreateManyInput | AnamnesisCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Anamnesis update
   */
  export type AnamnesisUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * The data needed to update a Anamnesis.
     */
    data: XOR<AnamnesisUpdateInput, AnamnesisUncheckedUpdateInput>
    /**
     * Choose, which Anamnesis to update.
     */
    where: AnamnesisWhereUniqueInput
  }


  /**
   * Anamnesis updateMany
   */
  export type AnamnesisUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Anamneses.
     */
    data: XOR<AnamnesisUpdateManyMutationInput, AnamnesisUncheckedUpdateManyInput>
    /**
     * Filter which Anamneses to update
     */
    where?: AnamnesisWhereInput
  }


  /**
   * Anamnesis upsert
   */
  export type AnamnesisUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * The filter to search for the Anamnesis to update in case it exists.
     */
    where: AnamnesisWhereUniqueInput
    /**
     * In case the Anamnesis found by the `where` argument doesn't exist, create a new Anamnesis with this data.
     */
    create: XOR<AnamnesisCreateInput, AnamnesisUncheckedCreateInput>
    /**
     * In case the Anamnesis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnamnesisUpdateInput, AnamnesisUncheckedUpdateInput>
  }


  /**
   * Anamnesis delete
   */
  export type AnamnesisDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Filter which Anamnesis to delete.
     */
    where: AnamnesisWhereUniqueInput
  }


  /**
   * Anamnesis deleteMany
   */
  export type AnamnesisDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Anamneses to delete
     */
    where?: AnamnesisWhereInput
  }


  /**
   * Anamnesis without action
   */
  export type AnamnesisDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
  }



  /**
   * Model Athlete
   */

  export type AggregateAthlete = {
    _count: AthleteCountAggregateOutputType | null
    _min: AthleteMinAggregateOutputType | null
    _max: AthleteMaxAggregateOutputType | null
  }

  export type AthleteMinAggregateOutputType = {
    id: string | null
    name: string | null
    surname: string | null
    phone: string | null
    email: string | null
    avatar: string | null
    sex: string | null
    observation: string | null
    birthDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AthleteMaxAggregateOutputType = {
    id: string | null
    name: string | null
    surname: string | null
    phone: string | null
    email: string | null
    avatar: string | null
    sex: string | null
    observation: string | null
    birthDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AthleteCountAggregateOutputType = {
    id: number
    name: number
    surname: number
    phone: number
    email: number
    avatar: number
    sex: number
    observation: number
    birthDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AthleteMinAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    phone?: true
    email?: true
    avatar?: true
    sex?: true
    observation?: true
    birthDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AthleteMaxAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    phone?: true
    email?: true
    avatar?: true
    sex?: true
    observation?: true
    birthDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AthleteCountAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    phone?: true
    email?: true
    avatar?: true
    sex?: true
    observation?: true
    birthDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AthleteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Athlete to aggregate.
     */
    where?: AthleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Athletes to fetch.
     */
    orderBy?: AthleteOrderByWithRelationInput | AthleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AthleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Athletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Athletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Athletes
    **/
    _count?: true | AthleteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AthleteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AthleteMaxAggregateInputType
  }

  export type GetAthleteAggregateType<T extends AthleteAggregateArgs> = {
        [P in keyof T & keyof AggregateAthlete]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAthlete[P]>
      : GetScalarType<T[P], AggregateAthlete[P]>
  }




  export type AthleteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AthleteWhereInput
    orderBy?: AthleteOrderByWithAggregationInput | AthleteOrderByWithAggregationInput[]
    by: AthleteScalarFieldEnum[] | AthleteScalarFieldEnum
    having?: AthleteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AthleteCountAggregateInputType | true
    _min?: AthleteMinAggregateInputType
    _max?: AthleteMaxAggregateInputType
  }

  export type AthleteGroupByOutputType = {
    id: string
    name: string
    surname: string
    phone: string
    email: string
    avatar: string | null
    sex: string
    observation: string | null
    birthDate: Date
    createdAt: Date
    updatedAt: Date | null
    _count: AthleteCountAggregateOutputType | null
    _min: AthleteMinAggregateOutputType | null
    _max: AthleteMaxAggregateOutputType | null
  }

  type GetAthleteGroupByPayload<T extends AthleteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AthleteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AthleteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AthleteGroupByOutputType[P]>
            : GetScalarType<T[P], AthleteGroupByOutputType[P]>
        }
      >
    >


  export type AthleteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    surname?: boolean
    phone?: boolean
    email?: boolean
    avatar?: boolean
    sex?: boolean
    observation?: boolean
    birthDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["athlete"]>

  export type AthleteSelectScalar = {
    id?: boolean
    name?: boolean
    surname?: boolean
    phone?: boolean
    email?: boolean
    avatar?: boolean
    sex?: boolean
    observation?: boolean
    birthDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $AthletePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Athlete"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: string
      name: string
      surname: string
      phone: string
      email: string
      avatar: string | null
      sex: string
      observation: string | null
      birthDate: Date
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["athlete"]>
    composites: {}
  }


  type AthleteGetPayload<S extends boolean | null | undefined | AthleteDefaultArgs> = $Result.GetResult<Prisma.$AthletePayload, S>

  type AthleteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AthleteFindManyArgs, 'select' | 'include'> & {
      select?: AthleteCountAggregateInputType | true
    }

  export interface AthleteDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Athlete'], meta: { name: 'Athlete' } }
    /**
     * Find zero or one Athlete that matches the filter.
     * @param {AthleteFindUniqueArgs} args - Arguments to find a Athlete
     * @example
     * // Get one Athlete
     * const athlete = await prisma.athlete.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AthleteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AthleteFindUniqueArgs<ExtArgs>>
    ): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Athlete that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AthleteFindUniqueOrThrowArgs} args - Arguments to find a Athlete
     * @example
     * // Get one Athlete
     * const athlete = await prisma.athlete.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AthleteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AthleteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Athlete that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteFindFirstArgs} args - Arguments to find a Athlete
     * @example
     * // Get one Athlete
     * const athlete = await prisma.athlete.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AthleteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AthleteFindFirstArgs<ExtArgs>>
    ): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Athlete that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteFindFirstOrThrowArgs} args - Arguments to find a Athlete
     * @example
     * // Get one Athlete
     * const athlete = await prisma.athlete.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AthleteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AthleteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Athletes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Athletes
     * const athletes = await prisma.athlete.findMany()
     * 
     * // Get first 10 Athletes
     * const athletes = await prisma.athlete.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const athleteWithIdOnly = await prisma.athlete.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AthleteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AthleteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Athlete.
     * @param {AthleteCreateArgs} args - Arguments to create a Athlete.
     * @example
     * // Create one Athlete
     * const Athlete = await prisma.athlete.create({
     *   data: {
     *     // ... data to create a Athlete
     *   }
     * })
     * 
    **/
    create<T extends AthleteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AthleteCreateArgs<ExtArgs>>
    ): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Athletes.
     *     @param {AthleteCreateManyArgs} args - Arguments to create many Athletes.
     *     @example
     *     // Create many Athletes
     *     const athlete = await prisma.athlete.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AthleteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AthleteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Athlete.
     * @param {AthleteDeleteArgs} args - Arguments to delete one Athlete.
     * @example
     * // Delete one Athlete
     * const Athlete = await prisma.athlete.delete({
     *   where: {
     *     // ... filter to delete one Athlete
     *   }
     * })
     * 
    **/
    delete<T extends AthleteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AthleteDeleteArgs<ExtArgs>>
    ): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Athlete.
     * @param {AthleteUpdateArgs} args - Arguments to update one Athlete.
     * @example
     * // Update one Athlete
     * const athlete = await prisma.athlete.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AthleteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AthleteUpdateArgs<ExtArgs>>
    ): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Athletes.
     * @param {AthleteDeleteManyArgs} args - Arguments to filter Athletes to delete.
     * @example
     * // Delete a few Athletes
     * const { count } = await prisma.athlete.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AthleteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AthleteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Athletes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Athletes
     * const athlete = await prisma.athlete.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AthleteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AthleteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Athlete.
     * @param {AthleteUpsertArgs} args - Arguments to update or create a Athlete.
     * @example
     * // Update or create a Athlete
     * const athlete = await prisma.athlete.upsert({
     *   create: {
     *     // ... data to create a Athlete
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Athlete we want to update
     *   }
     * })
    **/
    upsert<T extends AthleteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AthleteUpsertArgs<ExtArgs>>
    ): Prisma__AthleteClient<$Result.GetResult<Prisma.$AthletePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Athletes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteCountArgs} args - Arguments to filter Athletes to count.
     * @example
     * // Count the number of Athletes
     * const count = await prisma.athlete.count({
     *   where: {
     *     // ... the filter for the Athletes we want to count
     *   }
     * })
    **/
    count<T extends AthleteCountArgs>(
      args?: Subset<T, AthleteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AthleteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Athlete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AthleteAggregateArgs>(args: Subset<T, AthleteAggregateArgs>): Prisma.PrismaPromise<GetAthleteAggregateType<T>>

    /**
     * Group by Athlete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AthleteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AthleteGroupByArgs['orderBy'] }
        : { orderBy?: AthleteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AthleteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAthleteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Athlete model
   */
  readonly fields: AthleteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Athlete.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AthleteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Athlete model
   */ 
  interface AthleteFieldRefs {
    readonly id: FieldRef<"Athlete", 'String'>
    readonly name: FieldRef<"Athlete", 'String'>
    readonly surname: FieldRef<"Athlete", 'String'>
    readonly phone: FieldRef<"Athlete", 'String'>
    readonly email: FieldRef<"Athlete", 'String'>
    readonly avatar: FieldRef<"Athlete", 'String'>
    readonly sex: FieldRef<"Athlete", 'String'>
    readonly observation: FieldRef<"Athlete", 'String'>
    readonly birthDate: FieldRef<"Athlete", 'DateTime'>
    readonly createdAt: FieldRef<"Athlete", 'DateTime'>
    readonly updatedAt: FieldRef<"Athlete", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Athlete findUnique
   */
  export type AthleteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Filter, which Athlete to fetch.
     */
    where: AthleteWhereUniqueInput
  }


  /**
   * Athlete findUniqueOrThrow
   */
  export type AthleteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Filter, which Athlete to fetch.
     */
    where: AthleteWhereUniqueInput
  }


  /**
   * Athlete findFirst
   */
  export type AthleteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Filter, which Athlete to fetch.
     */
    where?: AthleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Athletes to fetch.
     */
    orderBy?: AthleteOrderByWithRelationInput | AthleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Athletes.
     */
    cursor?: AthleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Athletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Athletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Athletes.
     */
    distinct?: AthleteScalarFieldEnum | AthleteScalarFieldEnum[]
  }


  /**
   * Athlete findFirstOrThrow
   */
  export type AthleteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Filter, which Athlete to fetch.
     */
    where?: AthleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Athletes to fetch.
     */
    orderBy?: AthleteOrderByWithRelationInput | AthleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Athletes.
     */
    cursor?: AthleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Athletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Athletes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Athletes.
     */
    distinct?: AthleteScalarFieldEnum | AthleteScalarFieldEnum[]
  }


  /**
   * Athlete findMany
   */
  export type AthleteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Filter, which Athletes to fetch.
     */
    where?: AthleteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Athletes to fetch.
     */
    orderBy?: AthleteOrderByWithRelationInput | AthleteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Athletes.
     */
    cursor?: AthleteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Athletes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Athletes.
     */
    skip?: number
    distinct?: AthleteScalarFieldEnum | AthleteScalarFieldEnum[]
  }


  /**
   * Athlete create
   */
  export type AthleteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * The data needed to create a Athlete.
     */
    data: XOR<AthleteCreateInput, AthleteUncheckedCreateInput>
  }


  /**
   * Athlete createMany
   */
  export type AthleteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Athletes.
     */
    data: AthleteCreateManyInput | AthleteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Athlete update
   */
  export type AthleteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * The data needed to update a Athlete.
     */
    data: XOR<AthleteUpdateInput, AthleteUncheckedUpdateInput>
    /**
     * Choose, which Athlete to update.
     */
    where: AthleteWhereUniqueInput
  }


  /**
   * Athlete updateMany
   */
  export type AthleteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Athletes.
     */
    data: XOR<AthleteUpdateManyMutationInput, AthleteUncheckedUpdateManyInput>
    /**
     * Filter which Athletes to update
     */
    where?: AthleteWhereInput
  }


  /**
   * Athlete upsert
   */
  export type AthleteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * The filter to search for the Athlete to update in case it exists.
     */
    where: AthleteWhereUniqueInput
    /**
     * In case the Athlete found by the `where` argument doesn't exist, create a new Athlete with this data.
     */
    create: XOR<AthleteCreateInput, AthleteUncheckedCreateInput>
    /**
     * In case the Athlete was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AthleteUpdateInput, AthleteUncheckedUpdateInput>
  }


  /**
   * Athlete delete
   */
  export type AthleteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
    /**
     * Filter which Athlete to delete.
     */
    where: AthleteWhereUniqueInput
  }


  /**
   * Athlete deleteMany
   */
  export type AthleteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Athletes to delete
     */
    where?: AthleteWhereInput
  }


  /**
   * Athlete without action
   */
  export type AthleteDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Athlete
     */
    select?: AthleteSelect<ExtArgs> | null
  }



  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
  }


  export type $AddressPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: string
    }, ExtArgs["result"]["address"]>
    composites: {}
  }


  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Address that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressCreateArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Address model
   */ 
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data?: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
  }


  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
  }



  /**
   * Model Trainer
   */

  export type AggregateTrainer = {
    _count: TrainerCountAggregateOutputType | null
    _min: TrainerMinAggregateOutputType | null
    _max: TrainerMaxAggregateOutputType | null
  }

  export type TrainerMinAggregateOutputType = {
    id: string | null
  }

  export type TrainerMaxAggregateOutputType = {
    id: string | null
  }

  export type TrainerCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type TrainerMinAggregateInputType = {
    id?: true
  }

  export type TrainerMaxAggregateInputType = {
    id?: true
  }

  export type TrainerCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type TrainerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trainer to aggregate.
     */
    where?: TrainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainers to fetch.
     */
    orderBy?: TrainerOrderByWithRelationInput | TrainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trainers
    **/
    _count?: true | TrainerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainerMaxAggregateInputType
  }

  export type GetTrainerAggregateType<T extends TrainerAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainer[P]>
      : GetScalarType<T[P], AggregateTrainer[P]>
  }




  export type TrainerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TrainerWhereInput
    orderBy?: TrainerOrderByWithAggregationInput | TrainerOrderByWithAggregationInput[]
    by: TrainerScalarFieldEnum[] | TrainerScalarFieldEnum
    having?: TrainerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainerCountAggregateInputType | true
    _min?: TrainerMinAggregateInputType
    _max?: TrainerMaxAggregateInputType
  }

  export type TrainerGroupByOutputType = {
    id: string
    _count: TrainerCountAggregateOutputType | null
    _min: TrainerMinAggregateOutputType | null
    _max: TrainerMaxAggregateOutputType | null
  }

  type GetTrainerGroupByPayload<T extends TrainerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainerGroupByOutputType[P]>
            : GetScalarType<T[P], TrainerGroupByOutputType[P]>
        }
      >
    >


  export type TrainerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["trainer"]>

  export type TrainerSelectScalar = {
    id?: boolean
  }


  export type $TrainerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Trainer"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: string
    }, ExtArgs["result"]["trainer"]>
    composites: {}
  }


  type TrainerGetPayload<S extends boolean | null | undefined | TrainerDefaultArgs> = $Result.GetResult<Prisma.$TrainerPayload, S>

  type TrainerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TrainerFindManyArgs, 'select' | 'include'> & {
      select?: TrainerCountAggregateInputType | true
    }

  export interface TrainerDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trainer'], meta: { name: 'Trainer' } }
    /**
     * Find zero or one Trainer that matches the filter.
     * @param {TrainerFindUniqueArgs} args - Arguments to find a Trainer
     * @example
     * // Get one Trainer
     * const trainer = await prisma.trainer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrainerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TrainerFindUniqueArgs<ExtArgs>>
    ): Prisma__TrainerClient<$Result.GetResult<Prisma.$TrainerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Trainer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TrainerFindUniqueOrThrowArgs} args - Arguments to find a Trainer
     * @example
     * // Get one Trainer
     * const trainer = await prisma.trainer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrainerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TrainerClient<$Result.GetResult<Prisma.$TrainerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Trainer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerFindFirstArgs} args - Arguments to find a Trainer
     * @example
     * // Get one Trainer
     * const trainer = await prisma.trainer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrainerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainerFindFirstArgs<ExtArgs>>
    ): Prisma__TrainerClient<$Result.GetResult<Prisma.$TrainerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Trainer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerFindFirstOrThrowArgs} args - Arguments to find a Trainer
     * @example
     * // Get one Trainer
     * const trainer = await prisma.trainer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrainerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TrainerClient<$Result.GetResult<Prisma.$TrainerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Trainers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trainers
     * const trainers = await prisma.trainer.findMany()
     * 
     * // Get first 10 Trainers
     * const trainers = await prisma.trainer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainerWithIdOnly = await prisma.trainer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TrainerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Trainer.
     * @param {TrainerCreateArgs} args - Arguments to create a Trainer.
     * @example
     * // Create one Trainer
     * const Trainer = await prisma.trainer.create({
     *   data: {
     *     // ... data to create a Trainer
     *   }
     * })
     * 
    **/
    create<T extends TrainerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TrainerCreateArgs<ExtArgs>>
    ): Prisma__TrainerClient<$Result.GetResult<Prisma.$TrainerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Trainers.
     *     @param {TrainerCreateManyArgs} args - Arguments to create many Trainers.
     *     @example
     *     // Create many Trainers
     *     const trainer = await prisma.trainer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrainerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trainer.
     * @param {TrainerDeleteArgs} args - Arguments to delete one Trainer.
     * @example
     * // Delete one Trainer
     * const Trainer = await prisma.trainer.delete({
     *   where: {
     *     // ... filter to delete one Trainer
     *   }
     * })
     * 
    **/
    delete<T extends TrainerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TrainerDeleteArgs<ExtArgs>>
    ): Prisma__TrainerClient<$Result.GetResult<Prisma.$TrainerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Trainer.
     * @param {TrainerUpdateArgs} args - Arguments to update one Trainer.
     * @example
     * // Update one Trainer
     * const trainer = await prisma.trainer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrainerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TrainerUpdateArgs<ExtArgs>>
    ): Prisma__TrainerClient<$Result.GetResult<Prisma.$TrainerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Trainers.
     * @param {TrainerDeleteManyArgs} args - Arguments to filter Trainers to delete.
     * @example
     * // Delete a few Trainers
     * const { count } = await prisma.trainer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrainerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trainers
     * const trainer = await prisma.trainer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrainerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TrainerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trainer.
     * @param {TrainerUpsertArgs} args - Arguments to update or create a Trainer.
     * @example
     * // Update or create a Trainer
     * const trainer = await prisma.trainer.upsert({
     *   create: {
     *     // ... data to create a Trainer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trainer we want to update
     *   }
     * })
    **/
    upsert<T extends TrainerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TrainerUpsertArgs<ExtArgs>>
    ): Prisma__TrainerClient<$Result.GetResult<Prisma.$TrainerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Trainers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerCountArgs} args - Arguments to filter Trainers to count.
     * @example
     * // Count the number of Trainers
     * const count = await prisma.trainer.count({
     *   where: {
     *     // ... the filter for the Trainers we want to count
     *   }
     * })
    **/
    count<T extends TrainerCountArgs>(
      args?: Subset<T, TrainerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trainer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainerAggregateArgs>(args: Subset<T, TrainerAggregateArgs>): Prisma.PrismaPromise<GetTrainerAggregateType<T>>

    /**
     * Group by Trainer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainerGroupByArgs['orderBy'] }
        : { orderBy?: TrainerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trainer model
   */
  readonly fields: TrainerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trainer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Trainer model
   */ 
  interface TrainerFieldRefs {
    readonly id: FieldRef<"Trainer", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Trainer findUnique
   */
  export type TrainerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trainer
     */
    select?: TrainerSelect<ExtArgs> | null
    /**
     * Filter, which Trainer to fetch.
     */
    where: TrainerWhereUniqueInput
  }


  /**
   * Trainer findUniqueOrThrow
   */
  export type TrainerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trainer
     */
    select?: TrainerSelect<ExtArgs> | null
    /**
     * Filter, which Trainer to fetch.
     */
    where: TrainerWhereUniqueInput
  }


  /**
   * Trainer findFirst
   */
  export type TrainerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trainer
     */
    select?: TrainerSelect<ExtArgs> | null
    /**
     * Filter, which Trainer to fetch.
     */
    where?: TrainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainers to fetch.
     */
    orderBy?: TrainerOrderByWithRelationInput | TrainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trainers.
     */
    cursor?: TrainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trainers.
     */
    distinct?: TrainerScalarFieldEnum | TrainerScalarFieldEnum[]
  }


  /**
   * Trainer findFirstOrThrow
   */
  export type TrainerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trainer
     */
    select?: TrainerSelect<ExtArgs> | null
    /**
     * Filter, which Trainer to fetch.
     */
    where?: TrainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainers to fetch.
     */
    orderBy?: TrainerOrderByWithRelationInput | TrainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trainers.
     */
    cursor?: TrainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trainers.
     */
    distinct?: TrainerScalarFieldEnum | TrainerScalarFieldEnum[]
  }


  /**
   * Trainer findMany
   */
  export type TrainerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trainer
     */
    select?: TrainerSelect<ExtArgs> | null
    /**
     * Filter, which Trainers to fetch.
     */
    where?: TrainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainers to fetch.
     */
    orderBy?: TrainerOrderByWithRelationInput | TrainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trainers.
     */
    cursor?: TrainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainers.
     */
    skip?: number
    distinct?: TrainerScalarFieldEnum | TrainerScalarFieldEnum[]
  }


  /**
   * Trainer create
   */
  export type TrainerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trainer
     */
    select?: TrainerSelect<ExtArgs> | null
    /**
     * The data needed to create a Trainer.
     */
    data?: XOR<TrainerCreateInput, TrainerUncheckedCreateInput>
  }


  /**
   * Trainer createMany
   */
  export type TrainerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trainers.
     */
    data: TrainerCreateManyInput | TrainerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Trainer update
   */
  export type TrainerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trainer
     */
    select?: TrainerSelect<ExtArgs> | null
    /**
     * The data needed to update a Trainer.
     */
    data: XOR<TrainerUpdateInput, TrainerUncheckedUpdateInput>
    /**
     * Choose, which Trainer to update.
     */
    where: TrainerWhereUniqueInput
  }


  /**
   * Trainer updateMany
   */
  export type TrainerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trainers.
     */
    data: XOR<TrainerUpdateManyMutationInput, TrainerUncheckedUpdateManyInput>
    /**
     * Filter which Trainers to update
     */
    where?: TrainerWhereInput
  }


  /**
   * Trainer upsert
   */
  export type TrainerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trainer
     */
    select?: TrainerSelect<ExtArgs> | null
    /**
     * The filter to search for the Trainer to update in case it exists.
     */
    where: TrainerWhereUniqueInput
    /**
     * In case the Trainer found by the `where` argument doesn't exist, create a new Trainer with this data.
     */
    create: XOR<TrainerCreateInput, TrainerUncheckedCreateInput>
    /**
     * In case the Trainer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainerUpdateInput, TrainerUncheckedUpdateInput>
  }


  /**
   * Trainer delete
   */
  export type TrainerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trainer
     */
    select?: TrainerSelect<ExtArgs> | null
    /**
     * Filter which Trainer to delete.
     */
    where: TrainerWhereUniqueInput
  }


  /**
   * Trainer deleteMany
   */
  export type TrainerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trainers to delete
     */
    where?: TrainerWhereInput
  }


  /**
   * Trainer without action
   */
  export type TrainerDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trainer
     */
    select?: TrainerSelect<ExtArgs> | null
  }



  /**
   * Model BodyValuation
   */

  export type AggregateBodyValuation = {
    _count: BodyValuationCountAggregateOutputType | null
    _min: BodyValuationMinAggregateOutputType | null
    _max: BodyValuationMaxAggregateOutputType | null
  }

  export type BodyValuationMinAggregateOutputType = {
    id: string | null
  }

  export type BodyValuationMaxAggregateOutputType = {
    id: string | null
  }

  export type BodyValuationCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type BodyValuationMinAggregateInputType = {
    id?: true
  }

  export type BodyValuationMaxAggregateInputType = {
    id?: true
  }

  export type BodyValuationCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type BodyValuationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BodyValuation to aggregate.
     */
    where?: BodyValuationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyValuations to fetch.
     */
    orderBy?: BodyValuationOrderByWithRelationInput | BodyValuationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BodyValuationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyValuations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyValuations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BodyValuations
    **/
    _count?: true | BodyValuationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BodyValuationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BodyValuationMaxAggregateInputType
  }

  export type GetBodyValuationAggregateType<T extends BodyValuationAggregateArgs> = {
        [P in keyof T & keyof AggregateBodyValuation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBodyValuation[P]>
      : GetScalarType<T[P], AggregateBodyValuation[P]>
  }




  export type BodyValuationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BodyValuationWhereInput
    orderBy?: BodyValuationOrderByWithAggregationInput | BodyValuationOrderByWithAggregationInput[]
    by: BodyValuationScalarFieldEnum[] | BodyValuationScalarFieldEnum
    having?: BodyValuationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BodyValuationCountAggregateInputType | true
    _min?: BodyValuationMinAggregateInputType
    _max?: BodyValuationMaxAggregateInputType
  }

  export type BodyValuationGroupByOutputType = {
    id: string
    _count: BodyValuationCountAggregateOutputType | null
    _min: BodyValuationMinAggregateOutputType | null
    _max: BodyValuationMaxAggregateOutputType | null
  }

  type GetBodyValuationGroupByPayload<T extends BodyValuationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BodyValuationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BodyValuationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BodyValuationGroupByOutputType[P]>
            : GetScalarType<T[P], BodyValuationGroupByOutputType[P]>
        }
      >
    >


  export type BodyValuationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["bodyValuation"]>

  export type BodyValuationSelectScalar = {
    id?: boolean
  }


  export type $BodyValuationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "BodyValuation"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: string
    }, ExtArgs["result"]["bodyValuation"]>
    composites: {}
  }


  type BodyValuationGetPayload<S extends boolean | null | undefined | BodyValuationDefaultArgs> = $Result.GetResult<Prisma.$BodyValuationPayload, S>

  type BodyValuationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BodyValuationFindManyArgs, 'select' | 'include'> & {
      select?: BodyValuationCountAggregateInputType | true
    }

  export interface BodyValuationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BodyValuation'], meta: { name: 'BodyValuation' } }
    /**
     * Find zero or one BodyValuation that matches the filter.
     * @param {BodyValuationFindUniqueArgs} args - Arguments to find a BodyValuation
     * @example
     * // Get one BodyValuation
     * const bodyValuation = await prisma.bodyValuation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BodyValuationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BodyValuationFindUniqueArgs<ExtArgs>>
    ): Prisma__BodyValuationClient<$Result.GetResult<Prisma.$BodyValuationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BodyValuation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BodyValuationFindUniqueOrThrowArgs} args - Arguments to find a BodyValuation
     * @example
     * // Get one BodyValuation
     * const bodyValuation = await prisma.bodyValuation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BodyValuationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BodyValuationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BodyValuationClient<$Result.GetResult<Prisma.$BodyValuationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BodyValuation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyValuationFindFirstArgs} args - Arguments to find a BodyValuation
     * @example
     * // Get one BodyValuation
     * const bodyValuation = await prisma.bodyValuation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BodyValuationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BodyValuationFindFirstArgs<ExtArgs>>
    ): Prisma__BodyValuationClient<$Result.GetResult<Prisma.$BodyValuationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BodyValuation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyValuationFindFirstOrThrowArgs} args - Arguments to find a BodyValuation
     * @example
     * // Get one BodyValuation
     * const bodyValuation = await prisma.bodyValuation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BodyValuationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BodyValuationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BodyValuationClient<$Result.GetResult<Prisma.$BodyValuationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BodyValuations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyValuationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BodyValuations
     * const bodyValuations = await prisma.bodyValuation.findMany()
     * 
     * // Get first 10 BodyValuations
     * const bodyValuations = await prisma.bodyValuation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bodyValuationWithIdOnly = await prisma.bodyValuation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BodyValuationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BodyValuationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodyValuationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BodyValuation.
     * @param {BodyValuationCreateArgs} args - Arguments to create a BodyValuation.
     * @example
     * // Create one BodyValuation
     * const BodyValuation = await prisma.bodyValuation.create({
     *   data: {
     *     // ... data to create a BodyValuation
     *   }
     * })
     * 
    **/
    create<T extends BodyValuationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BodyValuationCreateArgs<ExtArgs>>
    ): Prisma__BodyValuationClient<$Result.GetResult<Prisma.$BodyValuationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BodyValuations.
     *     @param {BodyValuationCreateManyArgs} args - Arguments to create many BodyValuations.
     *     @example
     *     // Create many BodyValuations
     *     const bodyValuation = await prisma.bodyValuation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BodyValuationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BodyValuationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BodyValuation.
     * @param {BodyValuationDeleteArgs} args - Arguments to delete one BodyValuation.
     * @example
     * // Delete one BodyValuation
     * const BodyValuation = await prisma.bodyValuation.delete({
     *   where: {
     *     // ... filter to delete one BodyValuation
     *   }
     * })
     * 
    **/
    delete<T extends BodyValuationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BodyValuationDeleteArgs<ExtArgs>>
    ): Prisma__BodyValuationClient<$Result.GetResult<Prisma.$BodyValuationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BodyValuation.
     * @param {BodyValuationUpdateArgs} args - Arguments to update one BodyValuation.
     * @example
     * // Update one BodyValuation
     * const bodyValuation = await prisma.bodyValuation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BodyValuationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BodyValuationUpdateArgs<ExtArgs>>
    ): Prisma__BodyValuationClient<$Result.GetResult<Prisma.$BodyValuationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BodyValuations.
     * @param {BodyValuationDeleteManyArgs} args - Arguments to filter BodyValuations to delete.
     * @example
     * // Delete a few BodyValuations
     * const { count } = await prisma.bodyValuation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BodyValuationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BodyValuationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BodyValuations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyValuationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BodyValuations
     * const bodyValuation = await prisma.bodyValuation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BodyValuationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BodyValuationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BodyValuation.
     * @param {BodyValuationUpsertArgs} args - Arguments to update or create a BodyValuation.
     * @example
     * // Update or create a BodyValuation
     * const bodyValuation = await prisma.bodyValuation.upsert({
     *   create: {
     *     // ... data to create a BodyValuation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BodyValuation we want to update
     *   }
     * })
    **/
    upsert<T extends BodyValuationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BodyValuationUpsertArgs<ExtArgs>>
    ): Prisma__BodyValuationClient<$Result.GetResult<Prisma.$BodyValuationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BodyValuations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyValuationCountArgs} args - Arguments to filter BodyValuations to count.
     * @example
     * // Count the number of BodyValuations
     * const count = await prisma.bodyValuation.count({
     *   where: {
     *     // ... the filter for the BodyValuations we want to count
     *   }
     * })
    **/
    count<T extends BodyValuationCountArgs>(
      args?: Subset<T, BodyValuationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BodyValuationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BodyValuation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyValuationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BodyValuationAggregateArgs>(args: Subset<T, BodyValuationAggregateArgs>): Prisma.PrismaPromise<GetBodyValuationAggregateType<T>>

    /**
     * Group by BodyValuation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyValuationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BodyValuationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BodyValuationGroupByArgs['orderBy'] }
        : { orderBy?: BodyValuationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BodyValuationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBodyValuationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BodyValuation model
   */
  readonly fields: BodyValuationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BodyValuation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BodyValuationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BodyValuation model
   */ 
  interface BodyValuationFieldRefs {
    readonly id: FieldRef<"BodyValuation", 'String'>
  }
    

  // Custom InputTypes

  /**
   * BodyValuation findUnique
   */
  export type BodyValuationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyValuation
     */
    select?: BodyValuationSelect<ExtArgs> | null
    /**
     * Filter, which BodyValuation to fetch.
     */
    where: BodyValuationWhereUniqueInput
  }


  /**
   * BodyValuation findUniqueOrThrow
   */
  export type BodyValuationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyValuation
     */
    select?: BodyValuationSelect<ExtArgs> | null
    /**
     * Filter, which BodyValuation to fetch.
     */
    where: BodyValuationWhereUniqueInput
  }


  /**
   * BodyValuation findFirst
   */
  export type BodyValuationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyValuation
     */
    select?: BodyValuationSelect<ExtArgs> | null
    /**
     * Filter, which BodyValuation to fetch.
     */
    where?: BodyValuationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyValuations to fetch.
     */
    orderBy?: BodyValuationOrderByWithRelationInput | BodyValuationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BodyValuations.
     */
    cursor?: BodyValuationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyValuations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyValuations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BodyValuations.
     */
    distinct?: BodyValuationScalarFieldEnum | BodyValuationScalarFieldEnum[]
  }


  /**
   * BodyValuation findFirstOrThrow
   */
  export type BodyValuationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyValuation
     */
    select?: BodyValuationSelect<ExtArgs> | null
    /**
     * Filter, which BodyValuation to fetch.
     */
    where?: BodyValuationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyValuations to fetch.
     */
    orderBy?: BodyValuationOrderByWithRelationInput | BodyValuationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BodyValuations.
     */
    cursor?: BodyValuationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyValuations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyValuations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BodyValuations.
     */
    distinct?: BodyValuationScalarFieldEnum | BodyValuationScalarFieldEnum[]
  }


  /**
   * BodyValuation findMany
   */
  export type BodyValuationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyValuation
     */
    select?: BodyValuationSelect<ExtArgs> | null
    /**
     * Filter, which BodyValuations to fetch.
     */
    where?: BodyValuationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyValuations to fetch.
     */
    orderBy?: BodyValuationOrderByWithRelationInput | BodyValuationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BodyValuations.
     */
    cursor?: BodyValuationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyValuations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyValuations.
     */
    skip?: number
    distinct?: BodyValuationScalarFieldEnum | BodyValuationScalarFieldEnum[]
  }


  /**
   * BodyValuation create
   */
  export type BodyValuationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyValuation
     */
    select?: BodyValuationSelect<ExtArgs> | null
    /**
     * The data needed to create a BodyValuation.
     */
    data?: XOR<BodyValuationCreateInput, BodyValuationUncheckedCreateInput>
  }


  /**
   * BodyValuation createMany
   */
  export type BodyValuationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BodyValuations.
     */
    data: BodyValuationCreateManyInput | BodyValuationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BodyValuation update
   */
  export type BodyValuationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyValuation
     */
    select?: BodyValuationSelect<ExtArgs> | null
    /**
     * The data needed to update a BodyValuation.
     */
    data: XOR<BodyValuationUpdateInput, BodyValuationUncheckedUpdateInput>
    /**
     * Choose, which BodyValuation to update.
     */
    where: BodyValuationWhereUniqueInput
  }


  /**
   * BodyValuation updateMany
   */
  export type BodyValuationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BodyValuations.
     */
    data: XOR<BodyValuationUpdateManyMutationInput, BodyValuationUncheckedUpdateManyInput>
    /**
     * Filter which BodyValuations to update
     */
    where?: BodyValuationWhereInput
  }


  /**
   * BodyValuation upsert
   */
  export type BodyValuationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyValuation
     */
    select?: BodyValuationSelect<ExtArgs> | null
    /**
     * The filter to search for the BodyValuation to update in case it exists.
     */
    where: BodyValuationWhereUniqueInput
    /**
     * In case the BodyValuation found by the `where` argument doesn't exist, create a new BodyValuation with this data.
     */
    create: XOR<BodyValuationCreateInput, BodyValuationUncheckedCreateInput>
    /**
     * In case the BodyValuation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BodyValuationUpdateInput, BodyValuationUncheckedUpdateInput>
  }


  /**
   * BodyValuation delete
   */
  export type BodyValuationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyValuation
     */
    select?: BodyValuationSelect<ExtArgs> | null
    /**
     * Filter which BodyValuation to delete.
     */
    where: BodyValuationWhereUniqueInput
  }


  /**
   * BodyValuation deleteMany
   */
  export type BodyValuationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BodyValuations to delete
     */
    where?: BodyValuationWhereInput
  }


  /**
   * BodyValuation without action
   */
  export type BodyValuationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyValuation
     */
    select?: BodyValuationSelect<ExtArgs> | null
  }



  /**
   * Model Exercise
   */

  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: string | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: string | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type ExerciseMinAggregateInputType = {
    id?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type ExerciseAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercise to aggregate.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithAggregationInput | ExerciseOrderByWithAggregationInput[]
    by: ExerciseScalarFieldEnum[] | ExerciseScalarFieldEnum
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }

  export type ExerciseGroupByOutputType = {
    id: string
    _count: ExerciseCountAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectScalar = {
    id?: boolean
  }


  export type $ExercisePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Exercise"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: string
    }, ExtArgs["result"]["exercise"]>
    composites: {}
  }


  type ExerciseGetPayload<S extends boolean | null | undefined | ExerciseDefaultArgs> = $Result.GetResult<Prisma.$ExercisePayload, S>

  type ExerciseCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ExerciseFindManyArgs, 'select' | 'include'> & {
      select?: ExerciseCountAggregateInputType | true
    }

  export interface ExerciseDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exercise'], meta: { name: 'Exercise' } }
    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExerciseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ExerciseFindUniqueArgs<ExtArgs>>
    ): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Exercise that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ExerciseFindUniqueOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExerciseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExerciseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExerciseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ExerciseFindFirstArgs<ExtArgs>>
    ): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Exercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExerciseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExerciseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExerciseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExerciseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
    **/
    create<T extends ExerciseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ExerciseCreateArgs<ExtArgs>>
    ): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Exercises.
     *     @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     *     @example
     *     // Create many Exercises
     *     const exercise = await prisma.exercise.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExerciseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExerciseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
    **/
    delete<T extends ExerciseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ExerciseDeleteArgs<ExtArgs>>
    ): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExerciseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ExerciseUpdateArgs<ExtArgs>>
    ): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExerciseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExerciseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExerciseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ExerciseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
    **/
    upsert<T extends ExerciseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ExerciseUpsertArgs<ExtArgs>>
    ): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): Prisma.PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exercise model
   */
  readonly fields: ExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Exercise model
   */ 
  interface ExerciseFieldRefs {
    readonly id: FieldRef<"Exercise", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Exercise findUnique
   */
  export type ExerciseFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }


  /**
   * Exercise findUniqueOrThrow
   */
  export type ExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }


  /**
   * Exercise findFirst
   */
  export type ExerciseFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }


  /**
   * Exercise findFirstOrThrow
   */
  export type ExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }


  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Filter, which Exercises to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }


  /**
   * Exercise create
   */
  export type ExerciseCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * The data needed to create a Exercise.
     */
    data?: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }


  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * The data needed to update a Exercise.
     */
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     */
    where: ExerciseWhereUniqueInput
  }


  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
  }


  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     */
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     */
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }


  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Filter which Exercise to delete.
     */
    where: ExerciseWhereUniqueInput
  }


  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercises to delete
     */
    where?: ExerciseWhereInput
  }


  /**
   * Exercise without action
   */
  export type ExerciseDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
  }



  /**
   * Model FlexEvaluation
   */

  export type AggregateFlexEvaluation = {
    _count: FlexEvaluationCountAggregateOutputType | null
    _min: FlexEvaluationMinAggregateOutputType | null
    _max: FlexEvaluationMaxAggregateOutputType | null
  }

  export type FlexEvaluationMinAggregateOutputType = {
    id: string | null
  }

  export type FlexEvaluationMaxAggregateOutputType = {
    id: string | null
  }

  export type FlexEvaluationCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type FlexEvaluationMinAggregateInputType = {
    id?: true
  }

  export type FlexEvaluationMaxAggregateInputType = {
    id?: true
  }

  export type FlexEvaluationCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type FlexEvaluationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlexEvaluation to aggregate.
     */
    where?: FlexEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlexEvaluations to fetch.
     */
    orderBy?: FlexEvaluationOrderByWithRelationInput | FlexEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlexEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlexEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlexEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlexEvaluations
    **/
    _count?: true | FlexEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlexEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlexEvaluationMaxAggregateInputType
  }

  export type GetFlexEvaluationAggregateType<T extends FlexEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateFlexEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlexEvaluation[P]>
      : GetScalarType<T[P], AggregateFlexEvaluation[P]>
  }




  export type FlexEvaluationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FlexEvaluationWhereInput
    orderBy?: FlexEvaluationOrderByWithAggregationInput | FlexEvaluationOrderByWithAggregationInput[]
    by: FlexEvaluationScalarFieldEnum[] | FlexEvaluationScalarFieldEnum
    having?: FlexEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlexEvaluationCountAggregateInputType | true
    _min?: FlexEvaluationMinAggregateInputType
    _max?: FlexEvaluationMaxAggregateInputType
  }

  export type FlexEvaluationGroupByOutputType = {
    id: string
    _count: FlexEvaluationCountAggregateOutputType | null
    _min: FlexEvaluationMinAggregateOutputType | null
    _max: FlexEvaluationMaxAggregateOutputType | null
  }

  type GetFlexEvaluationGroupByPayload<T extends FlexEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlexEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlexEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlexEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], FlexEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type FlexEvaluationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["flexEvaluation"]>

  export type FlexEvaluationSelectScalar = {
    id?: boolean
  }


  export type $FlexEvaluationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "FlexEvaluation"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: string
    }, ExtArgs["result"]["flexEvaluation"]>
    composites: {}
  }


  type FlexEvaluationGetPayload<S extends boolean | null | undefined | FlexEvaluationDefaultArgs> = $Result.GetResult<Prisma.$FlexEvaluationPayload, S>

  type FlexEvaluationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<FlexEvaluationFindManyArgs, 'select' | 'include'> & {
      select?: FlexEvaluationCountAggregateInputType | true
    }

  export interface FlexEvaluationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlexEvaluation'], meta: { name: 'FlexEvaluation' } }
    /**
     * Find zero or one FlexEvaluation that matches the filter.
     * @param {FlexEvaluationFindUniqueArgs} args - Arguments to find a FlexEvaluation
     * @example
     * // Get one FlexEvaluation
     * const flexEvaluation = await prisma.flexEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FlexEvaluationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FlexEvaluationFindUniqueArgs<ExtArgs>>
    ): Prisma__FlexEvaluationClient<$Result.GetResult<Prisma.$FlexEvaluationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FlexEvaluation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FlexEvaluationFindUniqueOrThrowArgs} args - Arguments to find a FlexEvaluation
     * @example
     * // Get one FlexEvaluation
     * const flexEvaluation = await prisma.flexEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FlexEvaluationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FlexEvaluationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FlexEvaluationClient<$Result.GetResult<Prisma.$FlexEvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FlexEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlexEvaluationFindFirstArgs} args - Arguments to find a FlexEvaluation
     * @example
     * // Get one FlexEvaluation
     * const flexEvaluation = await prisma.flexEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FlexEvaluationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FlexEvaluationFindFirstArgs<ExtArgs>>
    ): Prisma__FlexEvaluationClient<$Result.GetResult<Prisma.$FlexEvaluationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FlexEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlexEvaluationFindFirstOrThrowArgs} args - Arguments to find a FlexEvaluation
     * @example
     * // Get one FlexEvaluation
     * const flexEvaluation = await prisma.flexEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FlexEvaluationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FlexEvaluationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FlexEvaluationClient<$Result.GetResult<Prisma.$FlexEvaluationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FlexEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlexEvaluationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlexEvaluations
     * const flexEvaluations = await prisma.flexEvaluation.findMany()
     * 
     * // Get first 10 FlexEvaluations
     * const flexEvaluations = await prisma.flexEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flexEvaluationWithIdOnly = await prisma.flexEvaluation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FlexEvaluationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FlexEvaluationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlexEvaluationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FlexEvaluation.
     * @param {FlexEvaluationCreateArgs} args - Arguments to create a FlexEvaluation.
     * @example
     * // Create one FlexEvaluation
     * const FlexEvaluation = await prisma.flexEvaluation.create({
     *   data: {
     *     // ... data to create a FlexEvaluation
     *   }
     * })
     * 
    **/
    create<T extends FlexEvaluationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FlexEvaluationCreateArgs<ExtArgs>>
    ): Prisma__FlexEvaluationClient<$Result.GetResult<Prisma.$FlexEvaluationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FlexEvaluations.
     *     @param {FlexEvaluationCreateManyArgs} args - Arguments to create many FlexEvaluations.
     *     @example
     *     // Create many FlexEvaluations
     *     const flexEvaluation = await prisma.flexEvaluation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FlexEvaluationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FlexEvaluationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FlexEvaluation.
     * @param {FlexEvaluationDeleteArgs} args - Arguments to delete one FlexEvaluation.
     * @example
     * // Delete one FlexEvaluation
     * const FlexEvaluation = await prisma.flexEvaluation.delete({
     *   where: {
     *     // ... filter to delete one FlexEvaluation
     *   }
     * })
     * 
    **/
    delete<T extends FlexEvaluationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FlexEvaluationDeleteArgs<ExtArgs>>
    ): Prisma__FlexEvaluationClient<$Result.GetResult<Prisma.$FlexEvaluationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FlexEvaluation.
     * @param {FlexEvaluationUpdateArgs} args - Arguments to update one FlexEvaluation.
     * @example
     * // Update one FlexEvaluation
     * const flexEvaluation = await prisma.flexEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FlexEvaluationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FlexEvaluationUpdateArgs<ExtArgs>>
    ): Prisma__FlexEvaluationClient<$Result.GetResult<Prisma.$FlexEvaluationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FlexEvaluations.
     * @param {FlexEvaluationDeleteManyArgs} args - Arguments to filter FlexEvaluations to delete.
     * @example
     * // Delete a few FlexEvaluations
     * const { count } = await prisma.flexEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FlexEvaluationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FlexEvaluationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlexEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlexEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlexEvaluations
     * const flexEvaluation = await prisma.flexEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FlexEvaluationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FlexEvaluationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FlexEvaluation.
     * @param {FlexEvaluationUpsertArgs} args - Arguments to update or create a FlexEvaluation.
     * @example
     * // Update or create a FlexEvaluation
     * const flexEvaluation = await prisma.flexEvaluation.upsert({
     *   create: {
     *     // ... data to create a FlexEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlexEvaluation we want to update
     *   }
     * })
    **/
    upsert<T extends FlexEvaluationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FlexEvaluationUpsertArgs<ExtArgs>>
    ): Prisma__FlexEvaluationClient<$Result.GetResult<Prisma.$FlexEvaluationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FlexEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlexEvaluationCountArgs} args - Arguments to filter FlexEvaluations to count.
     * @example
     * // Count the number of FlexEvaluations
     * const count = await prisma.flexEvaluation.count({
     *   where: {
     *     // ... the filter for the FlexEvaluations we want to count
     *   }
     * })
    **/
    count<T extends FlexEvaluationCountArgs>(
      args?: Subset<T, FlexEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlexEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlexEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlexEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlexEvaluationAggregateArgs>(args: Subset<T, FlexEvaluationAggregateArgs>): Prisma.PrismaPromise<GetFlexEvaluationAggregateType<T>>

    /**
     * Group by FlexEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlexEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlexEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlexEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: FlexEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlexEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlexEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlexEvaluation model
   */
  readonly fields: FlexEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlexEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlexEvaluationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FlexEvaluation model
   */ 
  interface FlexEvaluationFieldRefs {
    readonly id: FieldRef<"FlexEvaluation", 'String'>
  }
    

  // Custom InputTypes

  /**
   * FlexEvaluation findUnique
   */
  export type FlexEvaluationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexEvaluation
     */
    select?: FlexEvaluationSelect<ExtArgs> | null
    /**
     * Filter, which FlexEvaluation to fetch.
     */
    where: FlexEvaluationWhereUniqueInput
  }


  /**
   * FlexEvaluation findUniqueOrThrow
   */
  export type FlexEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexEvaluation
     */
    select?: FlexEvaluationSelect<ExtArgs> | null
    /**
     * Filter, which FlexEvaluation to fetch.
     */
    where: FlexEvaluationWhereUniqueInput
  }


  /**
   * FlexEvaluation findFirst
   */
  export type FlexEvaluationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexEvaluation
     */
    select?: FlexEvaluationSelect<ExtArgs> | null
    /**
     * Filter, which FlexEvaluation to fetch.
     */
    where?: FlexEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlexEvaluations to fetch.
     */
    orderBy?: FlexEvaluationOrderByWithRelationInput | FlexEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlexEvaluations.
     */
    cursor?: FlexEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlexEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlexEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlexEvaluations.
     */
    distinct?: FlexEvaluationScalarFieldEnum | FlexEvaluationScalarFieldEnum[]
  }


  /**
   * FlexEvaluation findFirstOrThrow
   */
  export type FlexEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexEvaluation
     */
    select?: FlexEvaluationSelect<ExtArgs> | null
    /**
     * Filter, which FlexEvaluation to fetch.
     */
    where?: FlexEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlexEvaluations to fetch.
     */
    orderBy?: FlexEvaluationOrderByWithRelationInput | FlexEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlexEvaluations.
     */
    cursor?: FlexEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlexEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlexEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlexEvaluations.
     */
    distinct?: FlexEvaluationScalarFieldEnum | FlexEvaluationScalarFieldEnum[]
  }


  /**
   * FlexEvaluation findMany
   */
  export type FlexEvaluationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexEvaluation
     */
    select?: FlexEvaluationSelect<ExtArgs> | null
    /**
     * Filter, which FlexEvaluations to fetch.
     */
    where?: FlexEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlexEvaluations to fetch.
     */
    orderBy?: FlexEvaluationOrderByWithRelationInput | FlexEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlexEvaluations.
     */
    cursor?: FlexEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlexEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlexEvaluations.
     */
    skip?: number
    distinct?: FlexEvaluationScalarFieldEnum | FlexEvaluationScalarFieldEnum[]
  }


  /**
   * FlexEvaluation create
   */
  export type FlexEvaluationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexEvaluation
     */
    select?: FlexEvaluationSelect<ExtArgs> | null
    /**
     * The data needed to create a FlexEvaluation.
     */
    data?: XOR<FlexEvaluationCreateInput, FlexEvaluationUncheckedCreateInput>
  }


  /**
   * FlexEvaluation createMany
   */
  export type FlexEvaluationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlexEvaluations.
     */
    data: FlexEvaluationCreateManyInput | FlexEvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * FlexEvaluation update
   */
  export type FlexEvaluationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexEvaluation
     */
    select?: FlexEvaluationSelect<ExtArgs> | null
    /**
     * The data needed to update a FlexEvaluation.
     */
    data: XOR<FlexEvaluationUpdateInput, FlexEvaluationUncheckedUpdateInput>
    /**
     * Choose, which FlexEvaluation to update.
     */
    where: FlexEvaluationWhereUniqueInput
  }


  /**
   * FlexEvaluation updateMany
   */
  export type FlexEvaluationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlexEvaluations.
     */
    data: XOR<FlexEvaluationUpdateManyMutationInput, FlexEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which FlexEvaluations to update
     */
    where?: FlexEvaluationWhereInput
  }


  /**
   * FlexEvaluation upsert
   */
  export type FlexEvaluationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexEvaluation
     */
    select?: FlexEvaluationSelect<ExtArgs> | null
    /**
     * The filter to search for the FlexEvaluation to update in case it exists.
     */
    where: FlexEvaluationWhereUniqueInput
    /**
     * In case the FlexEvaluation found by the `where` argument doesn't exist, create a new FlexEvaluation with this data.
     */
    create: XOR<FlexEvaluationCreateInput, FlexEvaluationUncheckedCreateInput>
    /**
     * In case the FlexEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlexEvaluationUpdateInput, FlexEvaluationUncheckedUpdateInput>
  }


  /**
   * FlexEvaluation delete
   */
  export type FlexEvaluationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexEvaluation
     */
    select?: FlexEvaluationSelect<ExtArgs> | null
    /**
     * Filter which FlexEvaluation to delete.
     */
    where: FlexEvaluationWhereUniqueInput
  }


  /**
   * FlexEvaluation deleteMany
   */
  export type FlexEvaluationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlexEvaluations to delete
     */
    where?: FlexEvaluationWhereInput
  }


  /**
   * FlexEvaluation without action
   */
  export type FlexEvaluationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexEvaluation
     */
    select?: FlexEvaluationSelect<ExtArgs> | null
  }



  /**
   * Model MethodExercise
   */

  export type AggregateMethodExercise = {
    _count: MethodExerciseCountAggregateOutputType | null
    _min: MethodExerciseMinAggregateOutputType | null
    _max: MethodExerciseMaxAggregateOutputType | null
  }

  export type MethodExerciseMinAggregateOutputType = {
    id: string | null
  }

  export type MethodExerciseMaxAggregateOutputType = {
    id: string | null
  }

  export type MethodExerciseCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type MethodExerciseMinAggregateInputType = {
    id?: true
  }

  export type MethodExerciseMaxAggregateInputType = {
    id?: true
  }

  export type MethodExerciseCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type MethodExerciseAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MethodExercise to aggregate.
     */
    where?: MethodExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MethodExercises to fetch.
     */
    orderBy?: MethodExerciseOrderByWithRelationInput | MethodExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MethodExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MethodExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MethodExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MethodExercises
    **/
    _count?: true | MethodExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MethodExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MethodExerciseMaxAggregateInputType
  }

  export type GetMethodExerciseAggregateType<T extends MethodExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateMethodExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMethodExercise[P]>
      : GetScalarType<T[P], AggregateMethodExercise[P]>
  }




  export type MethodExerciseGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MethodExerciseWhereInput
    orderBy?: MethodExerciseOrderByWithAggregationInput | MethodExerciseOrderByWithAggregationInput[]
    by: MethodExerciseScalarFieldEnum[] | MethodExerciseScalarFieldEnum
    having?: MethodExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MethodExerciseCountAggregateInputType | true
    _min?: MethodExerciseMinAggregateInputType
    _max?: MethodExerciseMaxAggregateInputType
  }

  export type MethodExerciseGroupByOutputType = {
    id: string
    _count: MethodExerciseCountAggregateOutputType | null
    _min: MethodExerciseMinAggregateOutputType | null
    _max: MethodExerciseMaxAggregateOutputType | null
  }

  type GetMethodExerciseGroupByPayload<T extends MethodExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MethodExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MethodExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MethodExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], MethodExerciseGroupByOutputType[P]>
        }
      >
    >


  export type MethodExerciseSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["methodExercise"]>

  export type MethodExerciseSelectScalar = {
    id?: boolean
  }


  export type $MethodExercisePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "MethodExercise"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: string
    }, ExtArgs["result"]["methodExercise"]>
    composites: {}
  }


  type MethodExerciseGetPayload<S extends boolean | null | undefined | MethodExerciseDefaultArgs> = $Result.GetResult<Prisma.$MethodExercisePayload, S>

  type MethodExerciseCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MethodExerciseFindManyArgs, 'select' | 'include'> & {
      select?: MethodExerciseCountAggregateInputType | true
    }

  export interface MethodExerciseDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MethodExercise'], meta: { name: 'MethodExercise' } }
    /**
     * Find zero or one MethodExercise that matches the filter.
     * @param {MethodExerciseFindUniqueArgs} args - Arguments to find a MethodExercise
     * @example
     * // Get one MethodExercise
     * const methodExercise = await prisma.methodExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MethodExerciseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MethodExerciseFindUniqueArgs<ExtArgs>>
    ): Prisma__MethodExerciseClient<$Result.GetResult<Prisma.$MethodExercisePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MethodExercise that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MethodExerciseFindUniqueOrThrowArgs} args - Arguments to find a MethodExercise
     * @example
     * // Get one MethodExercise
     * const methodExercise = await prisma.methodExercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MethodExerciseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MethodExerciseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MethodExerciseClient<$Result.GetResult<Prisma.$MethodExercisePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MethodExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodExerciseFindFirstArgs} args - Arguments to find a MethodExercise
     * @example
     * // Get one MethodExercise
     * const methodExercise = await prisma.methodExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MethodExerciseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MethodExerciseFindFirstArgs<ExtArgs>>
    ): Prisma__MethodExerciseClient<$Result.GetResult<Prisma.$MethodExercisePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MethodExercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodExerciseFindFirstOrThrowArgs} args - Arguments to find a MethodExercise
     * @example
     * // Get one MethodExercise
     * const methodExercise = await prisma.methodExercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MethodExerciseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MethodExerciseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MethodExerciseClient<$Result.GetResult<Prisma.$MethodExercisePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MethodExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodExerciseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MethodExercises
     * const methodExercises = await prisma.methodExercise.findMany()
     * 
     * // Get first 10 MethodExercises
     * const methodExercises = await prisma.methodExercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const methodExerciseWithIdOnly = await prisma.methodExercise.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MethodExerciseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MethodExerciseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MethodExercisePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MethodExercise.
     * @param {MethodExerciseCreateArgs} args - Arguments to create a MethodExercise.
     * @example
     * // Create one MethodExercise
     * const MethodExercise = await prisma.methodExercise.create({
     *   data: {
     *     // ... data to create a MethodExercise
     *   }
     * })
     * 
    **/
    create<T extends MethodExerciseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MethodExerciseCreateArgs<ExtArgs>>
    ): Prisma__MethodExerciseClient<$Result.GetResult<Prisma.$MethodExercisePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MethodExercises.
     *     @param {MethodExerciseCreateManyArgs} args - Arguments to create many MethodExercises.
     *     @example
     *     // Create many MethodExercises
     *     const methodExercise = await prisma.methodExercise.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MethodExerciseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MethodExerciseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MethodExercise.
     * @param {MethodExerciseDeleteArgs} args - Arguments to delete one MethodExercise.
     * @example
     * // Delete one MethodExercise
     * const MethodExercise = await prisma.methodExercise.delete({
     *   where: {
     *     // ... filter to delete one MethodExercise
     *   }
     * })
     * 
    **/
    delete<T extends MethodExerciseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MethodExerciseDeleteArgs<ExtArgs>>
    ): Prisma__MethodExerciseClient<$Result.GetResult<Prisma.$MethodExercisePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MethodExercise.
     * @param {MethodExerciseUpdateArgs} args - Arguments to update one MethodExercise.
     * @example
     * // Update one MethodExercise
     * const methodExercise = await prisma.methodExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MethodExerciseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MethodExerciseUpdateArgs<ExtArgs>>
    ): Prisma__MethodExerciseClient<$Result.GetResult<Prisma.$MethodExercisePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MethodExercises.
     * @param {MethodExerciseDeleteManyArgs} args - Arguments to filter MethodExercises to delete.
     * @example
     * // Delete a few MethodExercises
     * const { count } = await prisma.methodExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MethodExerciseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MethodExerciseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MethodExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MethodExercises
     * const methodExercise = await prisma.methodExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MethodExerciseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MethodExerciseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MethodExercise.
     * @param {MethodExerciseUpsertArgs} args - Arguments to update or create a MethodExercise.
     * @example
     * // Update or create a MethodExercise
     * const methodExercise = await prisma.methodExercise.upsert({
     *   create: {
     *     // ... data to create a MethodExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MethodExercise we want to update
     *   }
     * })
    **/
    upsert<T extends MethodExerciseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MethodExerciseUpsertArgs<ExtArgs>>
    ): Prisma__MethodExerciseClient<$Result.GetResult<Prisma.$MethodExercisePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MethodExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodExerciseCountArgs} args - Arguments to filter MethodExercises to count.
     * @example
     * // Count the number of MethodExercises
     * const count = await prisma.methodExercise.count({
     *   where: {
     *     // ... the filter for the MethodExercises we want to count
     *   }
     * })
    **/
    count<T extends MethodExerciseCountArgs>(
      args?: Subset<T, MethodExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MethodExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MethodExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MethodExerciseAggregateArgs>(args: Subset<T, MethodExerciseAggregateArgs>): Prisma.PrismaPromise<GetMethodExerciseAggregateType<T>>

    /**
     * Group by MethodExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MethodExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MethodExerciseGroupByArgs['orderBy'] }
        : { orderBy?: MethodExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MethodExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMethodExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MethodExercise model
   */
  readonly fields: MethodExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MethodExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MethodExerciseClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MethodExercise model
   */ 
  interface MethodExerciseFieldRefs {
    readonly id: FieldRef<"MethodExercise", 'String'>
  }
    

  // Custom InputTypes

  /**
   * MethodExercise findUnique
   */
  export type MethodExerciseFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodExercise
     */
    select?: MethodExerciseSelect<ExtArgs> | null
    /**
     * Filter, which MethodExercise to fetch.
     */
    where: MethodExerciseWhereUniqueInput
  }


  /**
   * MethodExercise findUniqueOrThrow
   */
  export type MethodExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodExercise
     */
    select?: MethodExerciseSelect<ExtArgs> | null
    /**
     * Filter, which MethodExercise to fetch.
     */
    where: MethodExerciseWhereUniqueInput
  }


  /**
   * MethodExercise findFirst
   */
  export type MethodExerciseFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodExercise
     */
    select?: MethodExerciseSelect<ExtArgs> | null
    /**
     * Filter, which MethodExercise to fetch.
     */
    where?: MethodExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MethodExercises to fetch.
     */
    orderBy?: MethodExerciseOrderByWithRelationInput | MethodExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MethodExercises.
     */
    cursor?: MethodExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MethodExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MethodExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MethodExercises.
     */
    distinct?: MethodExerciseScalarFieldEnum | MethodExerciseScalarFieldEnum[]
  }


  /**
   * MethodExercise findFirstOrThrow
   */
  export type MethodExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodExercise
     */
    select?: MethodExerciseSelect<ExtArgs> | null
    /**
     * Filter, which MethodExercise to fetch.
     */
    where?: MethodExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MethodExercises to fetch.
     */
    orderBy?: MethodExerciseOrderByWithRelationInput | MethodExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MethodExercises.
     */
    cursor?: MethodExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MethodExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MethodExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MethodExercises.
     */
    distinct?: MethodExerciseScalarFieldEnum | MethodExerciseScalarFieldEnum[]
  }


  /**
   * MethodExercise findMany
   */
  export type MethodExerciseFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodExercise
     */
    select?: MethodExerciseSelect<ExtArgs> | null
    /**
     * Filter, which MethodExercises to fetch.
     */
    where?: MethodExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MethodExercises to fetch.
     */
    orderBy?: MethodExerciseOrderByWithRelationInput | MethodExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MethodExercises.
     */
    cursor?: MethodExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MethodExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MethodExercises.
     */
    skip?: number
    distinct?: MethodExerciseScalarFieldEnum | MethodExerciseScalarFieldEnum[]
  }


  /**
   * MethodExercise create
   */
  export type MethodExerciseCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodExercise
     */
    select?: MethodExerciseSelect<ExtArgs> | null
    /**
     * The data needed to create a MethodExercise.
     */
    data?: XOR<MethodExerciseCreateInput, MethodExerciseUncheckedCreateInput>
  }


  /**
   * MethodExercise createMany
   */
  export type MethodExerciseCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MethodExercises.
     */
    data: MethodExerciseCreateManyInput | MethodExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MethodExercise update
   */
  export type MethodExerciseUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodExercise
     */
    select?: MethodExerciseSelect<ExtArgs> | null
    /**
     * The data needed to update a MethodExercise.
     */
    data: XOR<MethodExerciseUpdateInput, MethodExerciseUncheckedUpdateInput>
    /**
     * Choose, which MethodExercise to update.
     */
    where: MethodExerciseWhereUniqueInput
  }


  /**
   * MethodExercise updateMany
   */
  export type MethodExerciseUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MethodExercises.
     */
    data: XOR<MethodExerciseUpdateManyMutationInput, MethodExerciseUncheckedUpdateManyInput>
    /**
     * Filter which MethodExercises to update
     */
    where?: MethodExerciseWhereInput
  }


  /**
   * MethodExercise upsert
   */
  export type MethodExerciseUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodExercise
     */
    select?: MethodExerciseSelect<ExtArgs> | null
    /**
     * The filter to search for the MethodExercise to update in case it exists.
     */
    where: MethodExerciseWhereUniqueInput
    /**
     * In case the MethodExercise found by the `where` argument doesn't exist, create a new MethodExercise with this data.
     */
    create: XOR<MethodExerciseCreateInput, MethodExerciseUncheckedCreateInput>
    /**
     * In case the MethodExercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MethodExerciseUpdateInput, MethodExerciseUncheckedUpdateInput>
  }


  /**
   * MethodExercise delete
   */
  export type MethodExerciseDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodExercise
     */
    select?: MethodExerciseSelect<ExtArgs> | null
    /**
     * Filter which MethodExercise to delete.
     */
    where: MethodExerciseWhereUniqueInput
  }


  /**
   * MethodExercise deleteMany
   */
  export type MethodExerciseDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MethodExercises to delete
     */
    where?: MethodExerciseWhereInput
  }


  /**
   * MethodExercise without action
   */
  export type MethodExerciseDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodExercise
     */
    select?: MethodExerciseSelect<ExtArgs> | null
  }



  /**
   * Model StatusPhoto
   */

  export type AggregateStatusPhoto = {
    _count: StatusPhotoCountAggregateOutputType | null
    _min: StatusPhotoMinAggregateOutputType | null
    _max: StatusPhotoMaxAggregateOutputType | null
  }

  export type StatusPhotoMinAggregateOutputType = {
    id: string | null
  }

  export type StatusPhotoMaxAggregateOutputType = {
    id: string | null
  }

  export type StatusPhotoCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type StatusPhotoMinAggregateInputType = {
    id?: true
  }

  export type StatusPhotoMaxAggregateInputType = {
    id?: true
  }

  export type StatusPhotoCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type StatusPhotoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusPhoto to aggregate.
     */
    where?: StatusPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPhotos to fetch.
     */
    orderBy?: StatusPhotoOrderByWithRelationInput | StatusPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatusPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatusPhotos
    **/
    _count?: true | StatusPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusPhotoMaxAggregateInputType
  }

  export type GetStatusPhotoAggregateType<T extends StatusPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusPhoto[P]>
      : GetScalarType<T[P], AggregateStatusPhoto[P]>
  }




  export type StatusPhotoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StatusPhotoWhereInput
    orderBy?: StatusPhotoOrderByWithAggregationInput | StatusPhotoOrderByWithAggregationInput[]
    by: StatusPhotoScalarFieldEnum[] | StatusPhotoScalarFieldEnum
    having?: StatusPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusPhotoCountAggregateInputType | true
    _min?: StatusPhotoMinAggregateInputType
    _max?: StatusPhotoMaxAggregateInputType
  }

  export type StatusPhotoGroupByOutputType = {
    id: string
    _count: StatusPhotoCountAggregateOutputType | null
    _min: StatusPhotoMinAggregateOutputType | null
    _max: StatusPhotoMaxAggregateOutputType | null
  }

  type GetStatusPhotoGroupByPayload<T extends StatusPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], StatusPhotoGroupByOutputType[P]>
        }
      >
    >


  export type StatusPhotoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["statusPhoto"]>

  export type StatusPhotoSelectScalar = {
    id?: boolean
  }


  export type $StatusPhotoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "StatusPhoto"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: string
    }, ExtArgs["result"]["statusPhoto"]>
    composites: {}
  }


  type StatusPhotoGetPayload<S extends boolean | null | undefined | StatusPhotoDefaultArgs> = $Result.GetResult<Prisma.$StatusPhotoPayload, S>

  type StatusPhotoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StatusPhotoFindManyArgs, 'select' | 'include'> & {
      select?: StatusPhotoCountAggregateInputType | true
    }

  export interface StatusPhotoDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatusPhoto'], meta: { name: 'StatusPhoto' } }
    /**
     * Find zero or one StatusPhoto that matches the filter.
     * @param {StatusPhotoFindUniqueArgs} args - Arguments to find a StatusPhoto
     * @example
     * // Get one StatusPhoto
     * const statusPhoto = await prisma.statusPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StatusPhotoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPhotoFindUniqueArgs<ExtArgs>>
    ): Prisma__StatusPhotoClient<$Result.GetResult<Prisma.$StatusPhotoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StatusPhoto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StatusPhotoFindUniqueOrThrowArgs} args - Arguments to find a StatusPhoto
     * @example
     * // Get one StatusPhoto
     * const statusPhoto = await prisma.statusPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StatusPhotoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPhotoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StatusPhotoClient<$Result.GetResult<Prisma.$StatusPhotoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StatusPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPhotoFindFirstArgs} args - Arguments to find a StatusPhoto
     * @example
     * // Get one StatusPhoto
     * const statusPhoto = await prisma.statusPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StatusPhotoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPhotoFindFirstArgs<ExtArgs>>
    ): Prisma__StatusPhotoClient<$Result.GetResult<Prisma.$StatusPhotoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StatusPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPhotoFindFirstOrThrowArgs} args - Arguments to find a StatusPhoto
     * @example
     * // Get one StatusPhoto
     * const statusPhoto = await prisma.statusPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StatusPhotoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPhotoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StatusPhotoClient<$Result.GetResult<Prisma.$StatusPhotoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StatusPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPhotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusPhotos
     * const statusPhotos = await prisma.statusPhoto.findMany()
     * 
     * // Get first 10 StatusPhotos
     * const statusPhotos = await prisma.statusPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusPhotoWithIdOnly = await prisma.statusPhoto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StatusPhotoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPhotoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusPhotoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StatusPhoto.
     * @param {StatusPhotoCreateArgs} args - Arguments to create a StatusPhoto.
     * @example
     * // Create one StatusPhoto
     * const StatusPhoto = await prisma.statusPhoto.create({
     *   data: {
     *     // ... data to create a StatusPhoto
     *   }
     * })
     * 
    **/
    create<T extends StatusPhotoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPhotoCreateArgs<ExtArgs>>
    ): Prisma__StatusPhotoClient<$Result.GetResult<Prisma.$StatusPhotoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StatusPhotos.
     *     @param {StatusPhotoCreateManyArgs} args - Arguments to create many StatusPhotos.
     *     @example
     *     // Create many StatusPhotos
     *     const statusPhoto = await prisma.statusPhoto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StatusPhotoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPhotoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StatusPhoto.
     * @param {StatusPhotoDeleteArgs} args - Arguments to delete one StatusPhoto.
     * @example
     * // Delete one StatusPhoto
     * const StatusPhoto = await prisma.statusPhoto.delete({
     *   where: {
     *     // ... filter to delete one StatusPhoto
     *   }
     * })
     * 
    **/
    delete<T extends StatusPhotoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPhotoDeleteArgs<ExtArgs>>
    ): Prisma__StatusPhotoClient<$Result.GetResult<Prisma.$StatusPhotoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StatusPhoto.
     * @param {StatusPhotoUpdateArgs} args - Arguments to update one StatusPhoto.
     * @example
     * // Update one StatusPhoto
     * const statusPhoto = await prisma.statusPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StatusPhotoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPhotoUpdateArgs<ExtArgs>>
    ): Prisma__StatusPhotoClient<$Result.GetResult<Prisma.$StatusPhotoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StatusPhotos.
     * @param {StatusPhotoDeleteManyArgs} args - Arguments to filter StatusPhotos to delete.
     * @example
     * // Delete a few StatusPhotos
     * const { count } = await prisma.statusPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StatusPhotoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StatusPhotoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusPhotos
     * const statusPhoto = await prisma.statusPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StatusPhotoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPhotoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StatusPhoto.
     * @param {StatusPhotoUpsertArgs} args - Arguments to update or create a StatusPhoto.
     * @example
     * // Update or create a StatusPhoto
     * const statusPhoto = await prisma.statusPhoto.upsert({
     *   create: {
     *     // ... data to create a StatusPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusPhoto we want to update
     *   }
     * })
    **/
    upsert<T extends StatusPhotoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StatusPhotoUpsertArgs<ExtArgs>>
    ): Prisma__StatusPhotoClient<$Result.GetResult<Prisma.$StatusPhotoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StatusPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPhotoCountArgs} args - Arguments to filter StatusPhotos to count.
     * @example
     * // Count the number of StatusPhotos
     * const count = await prisma.statusPhoto.count({
     *   where: {
     *     // ... the filter for the StatusPhotos we want to count
     *   }
     * })
    **/
    count<T extends StatusPhotoCountArgs>(
      args?: Subset<T, StatusPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatusPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusPhotoAggregateArgs>(args: Subset<T, StatusPhotoAggregateArgs>): Prisma.PrismaPromise<GetStatusPhotoAggregateType<T>>

    /**
     * Group by StatusPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusPhotoGroupByArgs['orderBy'] }
        : { orderBy?: StatusPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatusPhoto model
   */
  readonly fields: StatusPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatusPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatusPhotoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StatusPhoto model
   */ 
  interface StatusPhotoFieldRefs {
    readonly id: FieldRef<"StatusPhoto", 'String'>
  }
    

  // Custom InputTypes

  /**
   * StatusPhoto findUnique
   */
  export type StatusPhotoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPhoto
     */
    select?: StatusPhotoSelect<ExtArgs> | null
    /**
     * Filter, which StatusPhoto to fetch.
     */
    where: StatusPhotoWhereUniqueInput
  }


  /**
   * StatusPhoto findUniqueOrThrow
   */
  export type StatusPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPhoto
     */
    select?: StatusPhotoSelect<ExtArgs> | null
    /**
     * Filter, which StatusPhoto to fetch.
     */
    where: StatusPhotoWhereUniqueInput
  }


  /**
   * StatusPhoto findFirst
   */
  export type StatusPhotoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPhoto
     */
    select?: StatusPhotoSelect<ExtArgs> | null
    /**
     * Filter, which StatusPhoto to fetch.
     */
    where?: StatusPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPhotos to fetch.
     */
    orderBy?: StatusPhotoOrderByWithRelationInput | StatusPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusPhotos.
     */
    cursor?: StatusPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusPhotos.
     */
    distinct?: StatusPhotoScalarFieldEnum | StatusPhotoScalarFieldEnum[]
  }


  /**
   * StatusPhoto findFirstOrThrow
   */
  export type StatusPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPhoto
     */
    select?: StatusPhotoSelect<ExtArgs> | null
    /**
     * Filter, which StatusPhoto to fetch.
     */
    where?: StatusPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPhotos to fetch.
     */
    orderBy?: StatusPhotoOrderByWithRelationInput | StatusPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusPhotos.
     */
    cursor?: StatusPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusPhotos.
     */
    distinct?: StatusPhotoScalarFieldEnum | StatusPhotoScalarFieldEnum[]
  }


  /**
   * StatusPhoto findMany
   */
  export type StatusPhotoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPhoto
     */
    select?: StatusPhotoSelect<ExtArgs> | null
    /**
     * Filter, which StatusPhotos to fetch.
     */
    where?: StatusPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusPhotos to fetch.
     */
    orderBy?: StatusPhotoOrderByWithRelationInput | StatusPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatusPhotos.
     */
    cursor?: StatusPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusPhotos.
     */
    skip?: number
    distinct?: StatusPhotoScalarFieldEnum | StatusPhotoScalarFieldEnum[]
  }


  /**
   * StatusPhoto create
   */
  export type StatusPhotoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPhoto
     */
    select?: StatusPhotoSelect<ExtArgs> | null
    /**
     * The data needed to create a StatusPhoto.
     */
    data?: XOR<StatusPhotoCreateInput, StatusPhotoUncheckedCreateInput>
  }


  /**
   * StatusPhoto createMany
   */
  export type StatusPhotoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatusPhotos.
     */
    data: StatusPhotoCreateManyInput | StatusPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StatusPhoto update
   */
  export type StatusPhotoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPhoto
     */
    select?: StatusPhotoSelect<ExtArgs> | null
    /**
     * The data needed to update a StatusPhoto.
     */
    data: XOR<StatusPhotoUpdateInput, StatusPhotoUncheckedUpdateInput>
    /**
     * Choose, which StatusPhoto to update.
     */
    where: StatusPhotoWhereUniqueInput
  }


  /**
   * StatusPhoto updateMany
   */
  export type StatusPhotoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatusPhotos.
     */
    data: XOR<StatusPhotoUpdateManyMutationInput, StatusPhotoUncheckedUpdateManyInput>
    /**
     * Filter which StatusPhotos to update
     */
    where?: StatusPhotoWhereInput
  }


  /**
   * StatusPhoto upsert
   */
  export type StatusPhotoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPhoto
     */
    select?: StatusPhotoSelect<ExtArgs> | null
    /**
     * The filter to search for the StatusPhoto to update in case it exists.
     */
    where: StatusPhotoWhereUniqueInput
    /**
     * In case the StatusPhoto found by the `where` argument doesn't exist, create a new StatusPhoto with this data.
     */
    create: XOR<StatusPhotoCreateInput, StatusPhotoUncheckedCreateInput>
    /**
     * In case the StatusPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatusPhotoUpdateInput, StatusPhotoUncheckedUpdateInput>
  }


  /**
   * StatusPhoto delete
   */
  export type StatusPhotoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPhoto
     */
    select?: StatusPhotoSelect<ExtArgs> | null
    /**
     * Filter which StatusPhoto to delete.
     */
    where: StatusPhotoWhereUniqueInput
  }


  /**
   * StatusPhoto deleteMany
   */
  export type StatusPhotoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusPhotos to delete
     */
    where?: StatusPhotoWhereInput
  }


  /**
   * StatusPhoto without action
   */
  export type StatusPhotoDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusPhoto
     */
    select?: StatusPhotoSelect<ExtArgs> | null
  }



  /**
   * Model Target
   */

  export type AggregateTarget = {
    _count: TargetCountAggregateOutputType | null
    _min: TargetMinAggregateOutputType | null
    _max: TargetMaxAggregateOutputType | null
  }

  export type TargetMinAggregateOutputType = {
    id: string | null
  }

  export type TargetMaxAggregateOutputType = {
    id: string | null
  }

  export type TargetCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type TargetMinAggregateInputType = {
    id?: true
  }

  export type TargetMaxAggregateInputType = {
    id?: true
  }

  export type TargetCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type TargetAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Target to aggregate.
     */
    where?: TargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Targets to fetch.
     */
    orderBy?: TargetOrderByWithRelationInput | TargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Targets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Targets
    **/
    _count?: true | TargetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TargetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TargetMaxAggregateInputType
  }

  export type GetTargetAggregateType<T extends TargetAggregateArgs> = {
        [P in keyof T & keyof AggregateTarget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTarget[P]>
      : GetScalarType<T[P], AggregateTarget[P]>
  }




  export type TargetGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TargetWhereInput
    orderBy?: TargetOrderByWithAggregationInput | TargetOrderByWithAggregationInput[]
    by: TargetScalarFieldEnum[] | TargetScalarFieldEnum
    having?: TargetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TargetCountAggregateInputType | true
    _min?: TargetMinAggregateInputType
    _max?: TargetMaxAggregateInputType
  }

  export type TargetGroupByOutputType = {
    id: string
    _count: TargetCountAggregateOutputType | null
    _min: TargetMinAggregateOutputType | null
    _max: TargetMaxAggregateOutputType | null
  }

  type GetTargetGroupByPayload<T extends TargetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TargetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TargetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TargetGroupByOutputType[P]>
            : GetScalarType<T[P], TargetGroupByOutputType[P]>
        }
      >
    >


  export type TargetSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["target"]>

  export type TargetSelectScalar = {
    id?: boolean
  }


  export type $TargetPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Target"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: string
    }, ExtArgs["result"]["target"]>
    composites: {}
  }


  type TargetGetPayload<S extends boolean | null | undefined | TargetDefaultArgs> = $Result.GetResult<Prisma.$TargetPayload, S>

  type TargetCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TargetFindManyArgs, 'select' | 'include'> & {
      select?: TargetCountAggregateInputType | true
    }

  export interface TargetDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Target'], meta: { name: 'Target' } }
    /**
     * Find zero or one Target that matches the filter.
     * @param {TargetFindUniqueArgs} args - Arguments to find a Target
     * @example
     * // Get one Target
     * const target = await prisma.target.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TargetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TargetFindUniqueArgs<ExtArgs>>
    ): Prisma__TargetClient<$Result.GetResult<Prisma.$TargetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Target that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TargetFindUniqueOrThrowArgs} args - Arguments to find a Target
     * @example
     * // Get one Target
     * const target = await prisma.target.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TargetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TargetClient<$Result.GetResult<Prisma.$TargetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Target that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetFindFirstArgs} args - Arguments to find a Target
     * @example
     * // Get one Target
     * const target = await prisma.target.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TargetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetFindFirstArgs<ExtArgs>>
    ): Prisma__TargetClient<$Result.GetResult<Prisma.$TargetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Target that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetFindFirstOrThrowArgs} args - Arguments to find a Target
     * @example
     * // Get one Target
     * const target = await prisma.target.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TargetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TargetClient<$Result.GetResult<Prisma.$TargetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Targets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Targets
     * const targets = await prisma.target.findMany()
     * 
     * // Get first 10 Targets
     * const targets = await prisma.target.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const targetWithIdOnly = await prisma.target.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TargetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TargetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Target.
     * @param {TargetCreateArgs} args - Arguments to create a Target.
     * @example
     * // Create one Target
     * const Target = await prisma.target.create({
     *   data: {
     *     // ... data to create a Target
     *   }
     * })
     * 
    **/
    create<T extends TargetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TargetCreateArgs<ExtArgs>>
    ): Prisma__TargetClient<$Result.GetResult<Prisma.$TargetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Targets.
     *     @param {TargetCreateManyArgs} args - Arguments to create many Targets.
     *     @example
     *     // Create many Targets
     *     const target = await prisma.target.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TargetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Target.
     * @param {TargetDeleteArgs} args - Arguments to delete one Target.
     * @example
     * // Delete one Target
     * const Target = await prisma.target.delete({
     *   where: {
     *     // ... filter to delete one Target
     *   }
     * })
     * 
    **/
    delete<T extends TargetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TargetDeleteArgs<ExtArgs>>
    ): Prisma__TargetClient<$Result.GetResult<Prisma.$TargetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Target.
     * @param {TargetUpdateArgs} args - Arguments to update one Target.
     * @example
     * // Update one Target
     * const target = await prisma.target.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TargetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TargetUpdateArgs<ExtArgs>>
    ): Prisma__TargetClient<$Result.GetResult<Prisma.$TargetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Targets.
     * @param {TargetDeleteManyArgs} args - Arguments to filter Targets to delete.
     * @example
     * // Delete a few Targets
     * const { count } = await prisma.target.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TargetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Targets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Targets
     * const target = await prisma.target.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TargetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TargetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Target.
     * @param {TargetUpsertArgs} args - Arguments to update or create a Target.
     * @example
     * // Update or create a Target
     * const target = await prisma.target.upsert({
     *   create: {
     *     // ... data to create a Target
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Target we want to update
     *   }
     * })
    **/
    upsert<T extends TargetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TargetUpsertArgs<ExtArgs>>
    ): Prisma__TargetClient<$Result.GetResult<Prisma.$TargetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Targets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetCountArgs} args - Arguments to filter Targets to count.
     * @example
     * // Count the number of Targets
     * const count = await prisma.target.count({
     *   where: {
     *     // ... the filter for the Targets we want to count
     *   }
     * })
    **/
    count<T extends TargetCountArgs>(
      args?: Subset<T, TargetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TargetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Target.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TargetAggregateArgs>(args: Subset<T, TargetAggregateArgs>): Prisma.PrismaPromise<GetTargetAggregateType<T>>

    /**
     * Group by Target.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TargetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TargetGroupByArgs['orderBy'] }
        : { orderBy?: TargetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TargetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTargetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Target model
   */
  readonly fields: TargetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Target.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TargetClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Target model
   */ 
  interface TargetFieldRefs {
    readonly id: FieldRef<"Target", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Target findUnique
   */
  export type TargetFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Target
     */
    select?: TargetSelect<ExtArgs> | null
    /**
     * Filter, which Target to fetch.
     */
    where: TargetWhereUniqueInput
  }


  /**
   * Target findUniqueOrThrow
   */
  export type TargetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Target
     */
    select?: TargetSelect<ExtArgs> | null
    /**
     * Filter, which Target to fetch.
     */
    where: TargetWhereUniqueInput
  }


  /**
   * Target findFirst
   */
  export type TargetFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Target
     */
    select?: TargetSelect<ExtArgs> | null
    /**
     * Filter, which Target to fetch.
     */
    where?: TargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Targets to fetch.
     */
    orderBy?: TargetOrderByWithRelationInput | TargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Targets.
     */
    cursor?: TargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Targets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Targets.
     */
    distinct?: TargetScalarFieldEnum | TargetScalarFieldEnum[]
  }


  /**
   * Target findFirstOrThrow
   */
  export type TargetFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Target
     */
    select?: TargetSelect<ExtArgs> | null
    /**
     * Filter, which Target to fetch.
     */
    where?: TargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Targets to fetch.
     */
    orderBy?: TargetOrderByWithRelationInput | TargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Targets.
     */
    cursor?: TargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Targets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Targets.
     */
    distinct?: TargetScalarFieldEnum | TargetScalarFieldEnum[]
  }


  /**
   * Target findMany
   */
  export type TargetFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Target
     */
    select?: TargetSelect<ExtArgs> | null
    /**
     * Filter, which Targets to fetch.
     */
    where?: TargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Targets to fetch.
     */
    orderBy?: TargetOrderByWithRelationInput | TargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Targets.
     */
    cursor?: TargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Targets.
     */
    skip?: number
    distinct?: TargetScalarFieldEnum | TargetScalarFieldEnum[]
  }


  /**
   * Target create
   */
  export type TargetCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Target
     */
    select?: TargetSelect<ExtArgs> | null
    /**
     * The data needed to create a Target.
     */
    data?: XOR<TargetCreateInput, TargetUncheckedCreateInput>
  }


  /**
   * Target createMany
   */
  export type TargetCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Targets.
     */
    data: TargetCreateManyInput | TargetCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Target update
   */
  export type TargetUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Target
     */
    select?: TargetSelect<ExtArgs> | null
    /**
     * The data needed to update a Target.
     */
    data: XOR<TargetUpdateInput, TargetUncheckedUpdateInput>
    /**
     * Choose, which Target to update.
     */
    where: TargetWhereUniqueInput
  }


  /**
   * Target updateMany
   */
  export type TargetUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Targets.
     */
    data: XOR<TargetUpdateManyMutationInput, TargetUncheckedUpdateManyInput>
    /**
     * Filter which Targets to update
     */
    where?: TargetWhereInput
  }


  /**
   * Target upsert
   */
  export type TargetUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Target
     */
    select?: TargetSelect<ExtArgs> | null
    /**
     * The filter to search for the Target to update in case it exists.
     */
    where: TargetWhereUniqueInput
    /**
     * In case the Target found by the `where` argument doesn't exist, create a new Target with this data.
     */
    create: XOR<TargetCreateInput, TargetUncheckedCreateInput>
    /**
     * In case the Target was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TargetUpdateInput, TargetUncheckedUpdateInput>
  }


  /**
   * Target delete
   */
  export type TargetDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Target
     */
    select?: TargetSelect<ExtArgs> | null
    /**
     * Filter which Target to delete.
     */
    where: TargetWhereUniqueInput
  }


  /**
   * Target deleteMany
   */
  export type TargetDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Targets to delete
     */
    where?: TargetWhereInput
  }


  /**
   * Target without action
   */
  export type TargetDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Target
     */
    select?: TargetSelect<ExtArgs> | null
  }



  /**
   * Model Training
   */

  export type AggregateTraining = {
    _count: TrainingCountAggregateOutputType | null
    _min: TrainingMinAggregateOutputType | null
    _max: TrainingMaxAggregateOutputType | null
  }

  export type TrainingMinAggregateOutputType = {
    id: string | null
  }

  export type TrainingMaxAggregateOutputType = {
    id: string | null
  }

  export type TrainingCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type TrainingMinAggregateInputType = {
    id?: true
  }

  export type TrainingMaxAggregateInputType = {
    id?: true
  }

  export type TrainingCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type TrainingAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Training to aggregate.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trainings
    **/
    _count?: true | TrainingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingMaxAggregateInputType
  }

  export type GetTrainingAggregateType<T extends TrainingAggregateArgs> = {
        [P in keyof T & keyof AggregateTraining]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraining[P]>
      : GetScalarType<T[P], AggregateTraining[P]>
  }




  export type TrainingGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TrainingWhereInput
    orderBy?: TrainingOrderByWithAggregationInput | TrainingOrderByWithAggregationInput[]
    by: TrainingScalarFieldEnum[] | TrainingScalarFieldEnum
    having?: TrainingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingCountAggregateInputType | true
    _min?: TrainingMinAggregateInputType
    _max?: TrainingMaxAggregateInputType
  }

  export type TrainingGroupByOutputType = {
    id: string
    _count: TrainingCountAggregateOutputType | null
    _min: TrainingMinAggregateOutputType | null
    _max: TrainingMaxAggregateOutputType | null
  }

  type GetTrainingGroupByPayload<T extends TrainingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingGroupByOutputType[P]>
        }
      >
    >


  export type TrainingSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["training"]>

  export type TrainingSelectScalar = {
    id?: boolean
  }


  export type $TrainingPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Training"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: string
    }, ExtArgs["result"]["training"]>
    composites: {}
  }


  type TrainingGetPayload<S extends boolean | null | undefined | TrainingDefaultArgs> = $Result.GetResult<Prisma.$TrainingPayload, S>

  type TrainingCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TrainingFindManyArgs, 'select' | 'include'> & {
      select?: TrainingCountAggregateInputType | true
    }

  export interface TrainingDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Training'], meta: { name: 'Training' } }
    /**
     * Find zero or one Training that matches the filter.
     * @param {TrainingFindUniqueArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrainingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingFindUniqueArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Training that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TrainingFindUniqueOrThrowArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrainingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Training that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindFirstArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrainingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingFindFirstArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Training that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindFirstOrThrowArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrainingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Trainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trainings
     * const trainings = await prisma.training.findMany()
     * 
     * // Get first 10 Trainings
     * const trainings = await prisma.training.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingWithIdOnly = await prisma.training.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TrainingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Training.
     * @param {TrainingCreateArgs} args - Arguments to create a Training.
     * @example
     * // Create one Training
     * const Training = await prisma.training.create({
     *   data: {
     *     // ... data to create a Training
     *   }
     * })
     * 
    **/
    create<T extends TrainingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingCreateArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Trainings.
     *     @param {TrainingCreateManyArgs} args - Arguments to create many Trainings.
     *     @example
     *     // Create many Trainings
     *     const training = await prisma.training.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrainingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Training.
     * @param {TrainingDeleteArgs} args - Arguments to delete one Training.
     * @example
     * // Delete one Training
     * const Training = await prisma.training.delete({
     *   where: {
     *     // ... filter to delete one Training
     *   }
     * })
     * 
    **/
    delete<T extends TrainingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingDeleteArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Training.
     * @param {TrainingUpdateArgs} args - Arguments to update one Training.
     * @example
     * // Update one Training
     * const training = await prisma.training.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrainingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingUpdateArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Trainings.
     * @param {TrainingDeleteManyArgs} args - Arguments to filter Trainings to delete.
     * @example
     * // Delete a few Trainings
     * const { count } = await prisma.training.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrainingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trainings
     * const training = await prisma.training.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrainingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Training.
     * @param {TrainingUpsertArgs} args - Arguments to update or create a Training.
     * @example
     * // Update or create a Training
     * const training = await prisma.training.upsert({
     *   create: {
     *     // ... data to create a Training
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Training we want to update
     *   }
     * })
    **/
    upsert<T extends TrainingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingUpsertArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCountArgs} args - Arguments to filter Trainings to count.
     * @example
     * // Count the number of Trainings
     * const count = await prisma.training.count({
     *   where: {
     *     // ... the filter for the Trainings we want to count
     *   }
     * })
    **/
    count<T extends TrainingCountArgs>(
      args?: Subset<T, TrainingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Training.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingAggregateArgs>(args: Subset<T, TrainingAggregateArgs>): Prisma.PrismaPromise<GetTrainingAggregateType<T>>

    /**
     * Group by Training.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingGroupByArgs['orderBy'] }
        : { orderBy?: TrainingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Training model
   */
  readonly fields: TrainingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Training.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Training model
   */ 
  interface TrainingFieldRefs {
    readonly id: FieldRef<"Training", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Training findUnique
   */
  export type TrainingFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where: TrainingWhereUniqueInput
  }


  /**
   * Training findUniqueOrThrow
   */
  export type TrainingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where: TrainingWhereUniqueInput
  }


  /**
   * Training findFirst
   */
  export type TrainingFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trainings.
     */
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }


  /**
   * Training findFirstOrThrow
   */
  export type TrainingFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trainings.
     */
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }


  /**
   * Training findMany
   */
  export type TrainingFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Filter, which Trainings to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }


  /**
   * Training create
   */
  export type TrainingCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * The data needed to create a Training.
     */
    data?: XOR<TrainingCreateInput, TrainingUncheckedCreateInput>
  }


  /**
   * Training createMany
   */
  export type TrainingCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trainings.
     */
    data: TrainingCreateManyInput | TrainingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Training update
   */
  export type TrainingUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * The data needed to update a Training.
     */
    data: XOR<TrainingUpdateInput, TrainingUncheckedUpdateInput>
    /**
     * Choose, which Training to update.
     */
    where: TrainingWhereUniqueInput
  }


  /**
   * Training updateMany
   */
  export type TrainingUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trainings.
     */
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyInput>
    /**
     * Filter which Trainings to update
     */
    where?: TrainingWhereInput
  }


  /**
   * Training upsert
   */
  export type TrainingUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * The filter to search for the Training to update in case it exists.
     */
    where: TrainingWhereUniqueInput
    /**
     * In case the Training found by the `where` argument doesn't exist, create a new Training with this data.
     */
    create: XOR<TrainingCreateInput, TrainingUncheckedCreateInput>
    /**
     * In case the Training was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingUpdateInput, TrainingUncheckedUpdateInput>
  }


  /**
   * Training delete
   */
  export type TrainingDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Filter which Training to delete.
     */
    where: TrainingWhereUniqueInput
  }


  /**
   * Training deleteMany
   */
  export type TrainingDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trainings to delete
     */
    where?: TrainingWhereInput
  }


  /**
   * Training without action
   */
  export type TrainingDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
  }



  /**
   * Model TrainingEvolution
   */

  export type AggregateTrainingEvolution = {
    _count: TrainingEvolutionCountAggregateOutputType | null
    _min: TrainingEvolutionMinAggregateOutputType | null
    _max: TrainingEvolutionMaxAggregateOutputType | null
  }

  export type TrainingEvolutionMinAggregateOutputType = {
    id: string | null
  }

  export type TrainingEvolutionMaxAggregateOutputType = {
    id: string | null
  }

  export type TrainingEvolutionCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type TrainingEvolutionMinAggregateInputType = {
    id?: true
  }

  export type TrainingEvolutionMaxAggregateInputType = {
    id?: true
  }

  export type TrainingEvolutionCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type TrainingEvolutionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingEvolution to aggregate.
     */
    where?: TrainingEvolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingEvolutions to fetch.
     */
    orderBy?: TrainingEvolutionOrderByWithRelationInput | TrainingEvolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingEvolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingEvolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingEvolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingEvolutions
    **/
    _count?: true | TrainingEvolutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingEvolutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingEvolutionMaxAggregateInputType
  }

  export type GetTrainingEvolutionAggregateType<T extends TrainingEvolutionAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingEvolution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingEvolution[P]>
      : GetScalarType<T[P], AggregateTrainingEvolution[P]>
  }




  export type TrainingEvolutionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TrainingEvolutionWhereInput
    orderBy?: TrainingEvolutionOrderByWithAggregationInput | TrainingEvolutionOrderByWithAggregationInput[]
    by: TrainingEvolutionScalarFieldEnum[] | TrainingEvolutionScalarFieldEnum
    having?: TrainingEvolutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingEvolutionCountAggregateInputType | true
    _min?: TrainingEvolutionMinAggregateInputType
    _max?: TrainingEvolutionMaxAggregateInputType
  }

  export type TrainingEvolutionGroupByOutputType = {
    id: string
    _count: TrainingEvolutionCountAggregateOutputType | null
    _min: TrainingEvolutionMinAggregateOutputType | null
    _max: TrainingEvolutionMaxAggregateOutputType | null
  }

  type GetTrainingEvolutionGroupByPayload<T extends TrainingEvolutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingEvolutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingEvolutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingEvolutionGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingEvolutionGroupByOutputType[P]>
        }
      >
    >


  export type TrainingEvolutionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["trainingEvolution"]>

  export type TrainingEvolutionSelectScalar = {
    id?: boolean
  }


  export type $TrainingEvolutionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "TrainingEvolution"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: string
    }, ExtArgs["result"]["trainingEvolution"]>
    composites: {}
  }


  type TrainingEvolutionGetPayload<S extends boolean | null | undefined | TrainingEvolutionDefaultArgs> = $Result.GetResult<Prisma.$TrainingEvolutionPayload, S>

  type TrainingEvolutionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TrainingEvolutionFindManyArgs, 'select' | 'include'> & {
      select?: TrainingEvolutionCountAggregateInputType | true
    }

  export interface TrainingEvolutionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingEvolution'], meta: { name: 'TrainingEvolution' } }
    /**
     * Find zero or one TrainingEvolution that matches the filter.
     * @param {TrainingEvolutionFindUniqueArgs} args - Arguments to find a TrainingEvolution
     * @example
     * // Get one TrainingEvolution
     * const trainingEvolution = await prisma.trainingEvolution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrainingEvolutionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingEvolutionFindUniqueArgs<ExtArgs>>
    ): Prisma__TrainingEvolutionClient<$Result.GetResult<Prisma.$TrainingEvolutionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TrainingEvolution that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TrainingEvolutionFindUniqueOrThrowArgs} args - Arguments to find a TrainingEvolution
     * @example
     * // Get one TrainingEvolution
     * const trainingEvolution = await prisma.trainingEvolution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrainingEvolutionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingEvolutionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TrainingEvolutionClient<$Result.GetResult<Prisma.$TrainingEvolutionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TrainingEvolution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEvolutionFindFirstArgs} args - Arguments to find a TrainingEvolution
     * @example
     * // Get one TrainingEvolution
     * const trainingEvolution = await prisma.trainingEvolution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrainingEvolutionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingEvolutionFindFirstArgs<ExtArgs>>
    ): Prisma__TrainingEvolutionClient<$Result.GetResult<Prisma.$TrainingEvolutionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TrainingEvolution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEvolutionFindFirstOrThrowArgs} args - Arguments to find a TrainingEvolution
     * @example
     * // Get one TrainingEvolution
     * const trainingEvolution = await prisma.trainingEvolution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrainingEvolutionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingEvolutionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TrainingEvolutionClient<$Result.GetResult<Prisma.$TrainingEvolutionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TrainingEvolutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEvolutionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingEvolutions
     * const trainingEvolutions = await prisma.trainingEvolution.findMany()
     * 
     * // Get first 10 TrainingEvolutions
     * const trainingEvolutions = await prisma.trainingEvolution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingEvolutionWithIdOnly = await prisma.trainingEvolution.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TrainingEvolutionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingEvolutionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingEvolutionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TrainingEvolution.
     * @param {TrainingEvolutionCreateArgs} args - Arguments to create a TrainingEvolution.
     * @example
     * // Create one TrainingEvolution
     * const TrainingEvolution = await prisma.trainingEvolution.create({
     *   data: {
     *     // ... data to create a TrainingEvolution
     *   }
     * })
     * 
    **/
    create<T extends TrainingEvolutionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingEvolutionCreateArgs<ExtArgs>>
    ): Prisma__TrainingEvolutionClient<$Result.GetResult<Prisma.$TrainingEvolutionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TrainingEvolutions.
     *     @param {TrainingEvolutionCreateManyArgs} args - Arguments to create many TrainingEvolutions.
     *     @example
     *     // Create many TrainingEvolutions
     *     const trainingEvolution = await prisma.trainingEvolution.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrainingEvolutionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingEvolutionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrainingEvolution.
     * @param {TrainingEvolutionDeleteArgs} args - Arguments to delete one TrainingEvolution.
     * @example
     * // Delete one TrainingEvolution
     * const TrainingEvolution = await prisma.trainingEvolution.delete({
     *   where: {
     *     // ... filter to delete one TrainingEvolution
     *   }
     * })
     * 
    **/
    delete<T extends TrainingEvolutionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingEvolutionDeleteArgs<ExtArgs>>
    ): Prisma__TrainingEvolutionClient<$Result.GetResult<Prisma.$TrainingEvolutionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TrainingEvolution.
     * @param {TrainingEvolutionUpdateArgs} args - Arguments to update one TrainingEvolution.
     * @example
     * // Update one TrainingEvolution
     * const trainingEvolution = await prisma.trainingEvolution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrainingEvolutionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingEvolutionUpdateArgs<ExtArgs>>
    ): Prisma__TrainingEvolutionClient<$Result.GetResult<Prisma.$TrainingEvolutionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TrainingEvolutions.
     * @param {TrainingEvolutionDeleteManyArgs} args - Arguments to filter TrainingEvolutions to delete.
     * @example
     * // Delete a few TrainingEvolutions
     * const { count } = await prisma.trainingEvolution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrainingEvolutionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingEvolutionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingEvolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEvolutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingEvolutions
     * const trainingEvolution = await prisma.trainingEvolution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrainingEvolutionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingEvolutionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingEvolution.
     * @param {TrainingEvolutionUpsertArgs} args - Arguments to update or create a TrainingEvolution.
     * @example
     * // Update or create a TrainingEvolution
     * const trainingEvolution = await prisma.trainingEvolution.upsert({
     *   create: {
     *     // ... data to create a TrainingEvolution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingEvolution we want to update
     *   }
     * })
    **/
    upsert<T extends TrainingEvolutionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingEvolutionUpsertArgs<ExtArgs>>
    ): Prisma__TrainingEvolutionClient<$Result.GetResult<Prisma.$TrainingEvolutionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TrainingEvolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEvolutionCountArgs} args - Arguments to filter TrainingEvolutions to count.
     * @example
     * // Count the number of TrainingEvolutions
     * const count = await prisma.trainingEvolution.count({
     *   where: {
     *     // ... the filter for the TrainingEvolutions we want to count
     *   }
     * })
    **/
    count<T extends TrainingEvolutionCountArgs>(
      args?: Subset<T, TrainingEvolutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingEvolutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingEvolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEvolutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingEvolutionAggregateArgs>(args: Subset<T, TrainingEvolutionAggregateArgs>): Prisma.PrismaPromise<GetTrainingEvolutionAggregateType<T>>

    /**
     * Group by TrainingEvolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEvolutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingEvolutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingEvolutionGroupByArgs['orderBy'] }
        : { orderBy?: TrainingEvolutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingEvolutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingEvolutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingEvolution model
   */
  readonly fields: TrainingEvolutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingEvolution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingEvolutionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TrainingEvolution model
   */ 
  interface TrainingEvolutionFieldRefs {
    readonly id: FieldRef<"TrainingEvolution", 'String'>
  }
    

  // Custom InputTypes

  /**
   * TrainingEvolution findUnique
   */
  export type TrainingEvolutionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvolution
     */
    select?: TrainingEvolutionSelect<ExtArgs> | null
    /**
     * Filter, which TrainingEvolution to fetch.
     */
    where: TrainingEvolutionWhereUniqueInput
  }


  /**
   * TrainingEvolution findUniqueOrThrow
   */
  export type TrainingEvolutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvolution
     */
    select?: TrainingEvolutionSelect<ExtArgs> | null
    /**
     * Filter, which TrainingEvolution to fetch.
     */
    where: TrainingEvolutionWhereUniqueInput
  }


  /**
   * TrainingEvolution findFirst
   */
  export type TrainingEvolutionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvolution
     */
    select?: TrainingEvolutionSelect<ExtArgs> | null
    /**
     * Filter, which TrainingEvolution to fetch.
     */
    where?: TrainingEvolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingEvolutions to fetch.
     */
    orderBy?: TrainingEvolutionOrderByWithRelationInput | TrainingEvolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingEvolutions.
     */
    cursor?: TrainingEvolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingEvolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingEvolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingEvolutions.
     */
    distinct?: TrainingEvolutionScalarFieldEnum | TrainingEvolutionScalarFieldEnum[]
  }


  /**
   * TrainingEvolution findFirstOrThrow
   */
  export type TrainingEvolutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvolution
     */
    select?: TrainingEvolutionSelect<ExtArgs> | null
    /**
     * Filter, which TrainingEvolution to fetch.
     */
    where?: TrainingEvolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingEvolutions to fetch.
     */
    orderBy?: TrainingEvolutionOrderByWithRelationInput | TrainingEvolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingEvolutions.
     */
    cursor?: TrainingEvolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingEvolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingEvolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingEvolutions.
     */
    distinct?: TrainingEvolutionScalarFieldEnum | TrainingEvolutionScalarFieldEnum[]
  }


  /**
   * TrainingEvolution findMany
   */
  export type TrainingEvolutionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvolution
     */
    select?: TrainingEvolutionSelect<ExtArgs> | null
    /**
     * Filter, which TrainingEvolutions to fetch.
     */
    where?: TrainingEvolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingEvolutions to fetch.
     */
    orderBy?: TrainingEvolutionOrderByWithRelationInput | TrainingEvolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingEvolutions.
     */
    cursor?: TrainingEvolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingEvolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingEvolutions.
     */
    skip?: number
    distinct?: TrainingEvolutionScalarFieldEnum | TrainingEvolutionScalarFieldEnum[]
  }


  /**
   * TrainingEvolution create
   */
  export type TrainingEvolutionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvolution
     */
    select?: TrainingEvolutionSelect<ExtArgs> | null
    /**
     * The data needed to create a TrainingEvolution.
     */
    data?: XOR<TrainingEvolutionCreateInput, TrainingEvolutionUncheckedCreateInput>
  }


  /**
   * TrainingEvolution createMany
   */
  export type TrainingEvolutionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingEvolutions.
     */
    data: TrainingEvolutionCreateManyInput | TrainingEvolutionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TrainingEvolution update
   */
  export type TrainingEvolutionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvolution
     */
    select?: TrainingEvolutionSelect<ExtArgs> | null
    /**
     * The data needed to update a TrainingEvolution.
     */
    data: XOR<TrainingEvolutionUpdateInput, TrainingEvolutionUncheckedUpdateInput>
    /**
     * Choose, which TrainingEvolution to update.
     */
    where: TrainingEvolutionWhereUniqueInput
  }


  /**
   * TrainingEvolution updateMany
   */
  export type TrainingEvolutionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingEvolutions.
     */
    data: XOR<TrainingEvolutionUpdateManyMutationInput, TrainingEvolutionUncheckedUpdateManyInput>
    /**
     * Filter which TrainingEvolutions to update
     */
    where?: TrainingEvolutionWhereInput
  }


  /**
   * TrainingEvolution upsert
   */
  export type TrainingEvolutionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvolution
     */
    select?: TrainingEvolutionSelect<ExtArgs> | null
    /**
     * The filter to search for the TrainingEvolution to update in case it exists.
     */
    where: TrainingEvolutionWhereUniqueInput
    /**
     * In case the TrainingEvolution found by the `where` argument doesn't exist, create a new TrainingEvolution with this data.
     */
    create: XOR<TrainingEvolutionCreateInput, TrainingEvolutionUncheckedCreateInput>
    /**
     * In case the TrainingEvolution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingEvolutionUpdateInput, TrainingEvolutionUncheckedUpdateInput>
  }


  /**
   * TrainingEvolution delete
   */
  export type TrainingEvolutionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvolution
     */
    select?: TrainingEvolutionSelect<ExtArgs> | null
    /**
     * Filter which TrainingEvolution to delete.
     */
    where: TrainingEvolutionWhereUniqueInput
  }


  /**
   * TrainingEvolution deleteMany
   */
  export type TrainingEvolutionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingEvolutions to delete
     */
    where?: TrainingEvolutionWhereInput
  }


  /**
   * TrainingEvolution without action
   */
  export type TrainingEvolutionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvolution
     */
    select?: TrainingEvolutionSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AnamnesisScalarFieldEnum: {
    id: 'id'
  };

  export type AnamnesisScalarFieldEnum = (typeof AnamnesisScalarFieldEnum)[keyof typeof AnamnesisScalarFieldEnum]


  export const AthleteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    surname: 'surname',
    phone: 'phone',
    email: 'email',
    avatar: 'avatar',
    sex: 'sex',
    observation: 'observation',
    birthDate: 'birthDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AthleteScalarFieldEnum = (typeof AthleteScalarFieldEnum)[keyof typeof AthleteScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const TrainerScalarFieldEnum: {
    id: 'id'
  };

  export type TrainerScalarFieldEnum = (typeof TrainerScalarFieldEnum)[keyof typeof TrainerScalarFieldEnum]


  export const BodyValuationScalarFieldEnum: {
    id: 'id'
  };

  export type BodyValuationScalarFieldEnum = (typeof BodyValuationScalarFieldEnum)[keyof typeof BodyValuationScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const FlexEvaluationScalarFieldEnum: {
    id: 'id'
  };

  export type FlexEvaluationScalarFieldEnum = (typeof FlexEvaluationScalarFieldEnum)[keyof typeof FlexEvaluationScalarFieldEnum]


  export const MethodExerciseScalarFieldEnum: {
    id: 'id'
  };

  export type MethodExerciseScalarFieldEnum = (typeof MethodExerciseScalarFieldEnum)[keyof typeof MethodExerciseScalarFieldEnum]


  export const StatusPhotoScalarFieldEnum: {
    id: 'id'
  };

  export type StatusPhotoScalarFieldEnum = (typeof StatusPhotoScalarFieldEnum)[keyof typeof StatusPhotoScalarFieldEnum]


  export const TargetScalarFieldEnum: {
    id: 'id'
  };

  export type TargetScalarFieldEnum = (typeof TargetScalarFieldEnum)[keyof typeof TargetScalarFieldEnum]


  export const TrainingScalarFieldEnum: {
    id: 'id'
  };

  export type TrainingScalarFieldEnum = (typeof TrainingScalarFieldEnum)[keyof typeof TrainingScalarFieldEnum]


  export const TrainingEvolutionScalarFieldEnum: {
    id: 'id'
  };

  export type TrainingEvolutionScalarFieldEnum = (typeof TrainingEvolutionScalarFieldEnum)[keyof typeof TrainingEvolutionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    
  /**
   * Deep Input Types
   */


  export type AnamnesisWhereInput = {
    AND?: AnamnesisWhereInput | AnamnesisWhereInput[]
    OR?: AnamnesisWhereInput[]
    NOT?: AnamnesisWhereInput | AnamnesisWhereInput[]
    id?: StringFilter<"Anamnesis"> | string
  }

  export type AnamnesisOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type AnamnesisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnamnesisWhereInput | AnamnesisWhereInput[]
    OR?: AnamnesisWhereInput[]
    NOT?: AnamnesisWhereInput | AnamnesisWhereInput[]
  }, "id">

  export type AnamnesisOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: AnamnesisCountOrderByAggregateInput
    _max?: AnamnesisMaxOrderByAggregateInput
    _min?: AnamnesisMinOrderByAggregateInput
  }

  export type AnamnesisScalarWhereWithAggregatesInput = {
    AND?: AnamnesisScalarWhereWithAggregatesInput | AnamnesisScalarWhereWithAggregatesInput[]
    OR?: AnamnesisScalarWhereWithAggregatesInput[]
    NOT?: AnamnesisScalarWhereWithAggregatesInput | AnamnesisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Anamnesis"> | string
  }

  export type AthleteWhereInput = {
    AND?: AthleteWhereInput | AthleteWhereInput[]
    OR?: AthleteWhereInput[]
    NOT?: AthleteWhereInput | AthleteWhereInput[]
    id?: StringFilter<"Athlete"> | string
    name?: StringFilter<"Athlete"> | string
    surname?: StringFilter<"Athlete"> | string
    phone?: StringFilter<"Athlete"> | string
    email?: StringFilter<"Athlete"> | string
    avatar?: StringNullableFilter<"Athlete"> | string | null
    sex?: StringFilter<"Athlete"> | string
    observation?: StringNullableFilter<"Athlete"> | string | null
    birthDate?: DateTimeFilter<"Athlete"> | Date | string
    createdAt?: DateTimeFilter<"Athlete"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Athlete"> | Date | string | null
  }

  export type AthleteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    avatar?: SortOrderInput | SortOrder
    sex?: SortOrder
    observation?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type AthleteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AthleteWhereInput | AthleteWhereInput[]
    OR?: AthleteWhereInput[]
    NOT?: AthleteWhereInput | AthleteWhereInput[]
    name?: StringFilter<"Athlete"> | string
    surname?: StringFilter<"Athlete"> | string
    phone?: StringFilter<"Athlete"> | string
    avatar?: StringNullableFilter<"Athlete"> | string | null
    sex?: StringFilter<"Athlete"> | string
    observation?: StringNullableFilter<"Athlete"> | string | null
    birthDate?: DateTimeFilter<"Athlete"> | Date | string
    createdAt?: DateTimeFilter<"Athlete"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Athlete"> | Date | string | null
  }, "id" | "email">

  export type AthleteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    avatar?: SortOrderInput | SortOrder
    sex?: SortOrder
    observation?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: AthleteCountOrderByAggregateInput
    _max?: AthleteMaxOrderByAggregateInput
    _min?: AthleteMinOrderByAggregateInput
  }

  export type AthleteScalarWhereWithAggregatesInput = {
    AND?: AthleteScalarWhereWithAggregatesInput | AthleteScalarWhereWithAggregatesInput[]
    OR?: AthleteScalarWhereWithAggregatesInput[]
    NOT?: AthleteScalarWhereWithAggregatesInput | AthleteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Athlete"> | string
    name?: StringWithAggregatesFilter<"Athlete"> | string
    surname?: StringWithAggregatesFilter<"Athlete"> | string
    phone?: StringWithAggregatesFilter<"Athlete"> | string
    email?: StringWithAggregatesFilter<"Athlete"> | string
    avatar?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    sex?: StringWithAggregatesFilter<"Athlete"> | string
    observation?: StringNullableWithAggregatesFilter<"Athlete"> | string | null
    birthDate?: DateTimeWithAggregatesFilter<"Athlete"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Athlete"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Athlete"> | Date | string | null
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: StringFilter<"Address"> | string
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Address"> | string
  }

  export type TrainerWhereInput = {
    AND?: TrainerWhereInput | TrainerWhereInput[]
    OR?: TrainerWhereInput[]
    NOT?: TrainerWhereInput | TrainerWhereInput[]
    id?: StringFilter<"Trainer"> | string
  }

  export type TrainerOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type TrainerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainerWhereInput | TrainerWhereInput[]
    OR?: TrainerWhereInput[]
    NOT?: TrainerWhereInput | TrainerWhereInput[]
  }, "id">

  export type TrainerOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: TrainerCountOrderByAggregateInput
    _max?: TrainerMaxOrderByAggregateInput
    _min?: TrainerMinOrderByAggregateInput
  }

  export type TrainerScalarWhereWithAggregatesInput = {
    AND?: TrainerScalarWhereWithAggregatesInput | TrainerScalarWhereWithAggregatesInput[]
    OR?: TrainerScalarWhereWithAggregatesInput[]
    NOT?: TrainerScalarWhereWithAggregatesInput | TrainerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trainer"> | string
  }

  export type BodyValuationWhereInput = {
    AND?: BodyValuationWhereInput | BodyValuationWhereInput[]
    OR?: BodyValuationWhereInput[]
    NOT?: BodyValuationWhereInput | BodyValuationWhereInput[]
    id?: StringFilter<"BodyValuation"> | string
  }

  export type BodyValuationOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type BodyValuationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BodyValuationWhereInput | BodyValuationWhereInput[]
    OR?: BodyValuationWhereInput[]
    NOT?: BodyValuationWhereInput | BodyValuationWhereInput[]
  }, "id">

  export type BodyValuationOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: BodyValuationCountOrderByAggregateInput
    _max?: BodyValuationMaxOrderByAggregateInput
    _min?: BodyValuationMinOrderByAggregateInput
  }

  export type BodyValuationScalarWhereWithAggregatesInput = {
    AND?: BodyValuationScalarWhereWithAggregatesInput | BodyValuationScalarWhereWithAggregatesInput[]
    OR?: BodyValuationScalarWhereWithAggregatesInput[]
    NOT?: BodyValuationScalarWhereWithAggregatesInput | BodyValuationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BodyValuation"> | string
  }

  export type ExerciseWhereInput = {
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    id?: StringFilter<"Exercise"> | string
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type ExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
  }, "id">

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    OR?: ExerciseScalarWhereWithAggregatesInput[]
    NOT?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exercise"> | string
  }

  export type FlexEvaluationWhereInput = {
    AND?: FlexEvaluationWhereInput | FlexEvaluationWhereInput[]
    OR?: FlexEvaluationWhereInput[]
    NOT?: FlexEvaluationWhereInput | FlexEvaluationWhereInput[]
    id?: StringFilter<"FlexEvaluation"> | string
  }

  export type FlexEvaluationOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type FlexEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlexEvaluationWhereInput | FlexEvaluationWhereInput[]
    OR?: FlexEvaluationWhereInput[]
    NOT?: FlexEvaluationWhereInput | FlexEvaluationWhereInput[]
  }, "id">

  export type FlexEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: FlexEvaluationCountOrderByAggregateInput
    _max?: FlexEvaluationMaxOrderByAggregateInput
    _min?: FlexEvaluationMinOrderByAggregateInput
  }

  export type FlexEvaluationScalarWhereWithAggregatesInput = {
    AND?: FlexEvaluationScalarWhereWithAggregatesInput | FlexEvaluationScalarWhereWithAggregatesInput[]
    OR?: FlexEvaluationScalarWhereWithAggregatesInput[]
    NOT?: FlexEvaluationScalarWhereWithAggregatesInput | FlexEvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlexEvaluation"> | string
  }

  export type MethodExerciseWhereInput = {
    AND?: MethodExerciseWhereInput | MethodExerciseWhereInput[]
    OR?: MethodExerciseWhereInput[]
    NOT?: MethodExerciseWhereInput | MethodExerciseWhereInput[]
    id?: StringFilter<"MethodExercise"> | string
  }

  export type MethodExerciseOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type MethodExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MethodExerciseWhereInput | MethodExerciseWhereInput[]
    OR?: MethodExerciseWhereInput[]
    NOT?: MethodExerciseWhereInput | MethodExerciseWhereInput[]
  }, "id">

  export type MethodExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: MethodExerciseCountOrderByAggregateInput
    _max?: MethodExerciseMaxOrderByAggregateInput
    _min?: MethodExerciseMinOrderByAggregateInput
  }

  export type MethodExerciseScalarWhereWithAggregatesInput = {
    AND?: MethodExerciseScalarWhereWithAggregatesInput | MethodExerciseScalarWhereWithAggregatesInput[]
    OR?: MethodExerciseScalarWhereWithAggregatesInput[]
    NOT?: MethodExerciseScalarWhereWithAggregatesInput | MethodExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MethodExercise"> | string
  }

  export type StatusPhotoWhereInput = {
    AND?: StatusPhotoWhereInput | StatusPhotoWhereInput[]
    OR?: StatusPhotoWhereInput[]
    NOT?: StatusPhotoWhereInput | StatusPhotoWhereInput[]
    id?: StringFilter<"StatusPhoto"> | string
  }

  export type StatusPhotoOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type StatusPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StatusPhotoWhereInput | StatusPhotoWhereInput[]
    OR?: StatusPhotoWhereInput[]
    NOT?: StatusPhotoWhereInput | StatusPhotoWhereInput[]
  }, "id">

  export type StatusPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: StatusPhotoCountOrderByAggregateInput
    _max?: StatusPhotoMaxOrderByAggregateInput
    _min?: StatusPhotoMinOrderByAggregateInput
  }

  export type StatusPhotoScalarWhereWithAggregatesInput = {
    AND?: StatusPhotoScalarWhereWithAggregatesInput | StatusPhotoScalarWhereWithAggregatesInput[]
    OR?: StatusPhotoScalarWhereWithAggregatesInput[]
    NOT?: StatusPhotoScalarWhereWithAggregatesInput | StatusPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StatusPhoto"> | string
  }

  export type TargetWhereInput = {
    AND?: TargetWhereInput | TargetWhereInput[]
    OR?: TargetWhereInput[]
    NOT?: TargetWhereInput | TargetWhereInput[]
    id?: StringFilter<"Target"> | string
  }

  export type TargetOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type TargetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TargetWhereInput | TargetWhereInput[]
    OR?: TargetWhereInput[]
    NOT?: TargetWhereInput | TargetWhereInput[]
  }, "id">

  export type TargetOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: TargetCountOrderByAggregateInput
    _max?: TargetMaxOrderByAggregateInput
    _min?: TargetMinOrderByAggregateInput
  }

  export type TargetScalarWhereWithAggregatesInput = {
    AND?: TargetScalarWhereWithAggregatesInput | TargetScalarWhereWithAggregatesInput[]
    OR?: TargetScalarWhereWithAggregatesInput[]
    NOT?: TargetScalarWhereWithAggregatesInput | TargetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Target"> | string
  }

  export type TrainingWhereInput = {
    AND?: TrainingWhereInput | TrainingWhereInput[]
    OR?: TrainingWhereInput[]
    NOT?: TrainingWhereInput | TrainingWhereInput[]
    id?: StringFilter<"Training"> | string
  }

  export type TrainingOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type TrainingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingWhereInput | TrainingWhereInput[]
    OR?: TrainingWhereInput[]
    NOT?: TrainingWhereInput | TrainingWhereInput[]
  }, "id">

  export type TrainingOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: TrainingCountOrderByAggregateInput
    _max?: TrainingMaxOrderByAggregateInput
    _min?: TrainingMinOrderByAggregateInput
  }

  export type TrainingScalarWhereWithAggregatesInput = {
    AND?: TrainingScalarWhereWithAggregatesInput | TrainingScalarWhereWithAggregatesInput[]
    OR?: TrainingScalarWhereWithAggregatesInput[]
    NOT?: TrainingScalarWhereWithAggregatesInput | TrainingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Training"> | string
  }

  export type TrainingEvolutionWhereInput = {
    AND?: TrainingEvolutionWhereInput | TrainingEvolutionWhereInput[]
    OR?: TrainingEvolutionWhereInput[]
    NOT?: TrainingEvolutionWhereInput | TrainingEvolutionWhereInput[]
    id?: StringFilter<"TrainingEvolution"> | string
  }

  export type TrainingEvolutionOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type TrainingEvolutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingEvolutionWhereInput | TrainingEvolutionWhereInput[]
    OR?: TrainingEvolutionWhereInput[]
    NOT?: TrainingEvolutionWhereInput | TrainingEvolutionWhereInput[]
  }, "id">

  export type TrainingEvolutionOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: TrainingEvolutionCountOrderByAggregateInput
    _max?: TrainingEvolutionMaxOrderByAggregateInput
    _min?: TrainingEvolutionMinOrderByAggregateInput
  }

  export type TrainingEvolutionScalarWhereWithAggregatesInput = {
    AND?: TrainingEvolutionScalarWhereWithAggregatesInput | TrainingEvolutionScalarWhereWithAggregatesInput[]
    OR?: TrainingEvolutionScalarWhereWithAggregatesInput[]
    NOT?: TrainingEvolutionScalarWhereWithAggregatesInput | TrainingEvolutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingEvolution"> | string
  }

  export type AnamnesisCreateInput = {
    id?: string
  }

  export type AnamnesisUncheckedCreateInput = {
    id?: string
  }

  export type AnamnesisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AnamnesisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AnamnesisCreateManyInput = {
    id?: string
  }

  export type AnamnesisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AnamnesisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AthleteCreateInput = {
    id?: string
    name: string
    surname: string
    phone: string
    email: string
    avatar?: string | null
    sex: string
    observation?: string | null
    birthDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AthleteUncheckedCreateInput = {
    id?: string
    name: string
    surname: string
    phone: string
    email: string
    avatar?: string | null
    sex: string
    observation?: string | null
    birthDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AthleteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AthleteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AthleteCreateManyInput = {
    id?: string
    name: string
    surname: string
    phone: string
    email: string
    avatar?: string | null
    sex: string
    observation?: string | null
    birthDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AthleteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AthleteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AddressCreateInput = {
    id?: string
  }

  export type AddressUncheckedCreateInput = {
    id?: string
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateManyInput = {
    id?: string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TrainerCreateInput = {
    id?: string
  }

  export type TrainerUncheckedCreateInput = {
    id?: string
  }

  export type TrainerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TrainerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TrainerCreateManyInput = {
    id?: string
  }

  export type TrainerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TrainerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BodyValuationCreateInput = {
    id?: string
  }

  export type BodyValuationUncheckedCreateInput = {
    id?: string
  }

  export type BodyValuationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BodyValuationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BodyValuationCreateManyInput = {
    id?: string
  }

  export type BodyValuationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BodyValuationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ExerciseCreateInput = {
    id?: string
  }

  export type ExerciseUncheckedCreateInput = {
    id?: string
  }

  export type ExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ExerciseCreateManyInput = {
    id?: string
  }

  export type ExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type FlexEvaluationCreateInput = {
    id?: string
  }

  export type FlexEvaluationUncheckedCreateInput = {
    id?: string
  }

  export type FlexEvaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type FlexEvaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type FlexEvaluationCreateManyInput = {
    id?: string
  }

  export type FlexEvaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type FlexEvaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type MethodExerciseCreateInput = {
    id?: string
  }

  export type MethodExerciseUncheckedCreateInput = {
    id?: string
  }

  export type MethodExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type MethodExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type MethodExerciseCreateManyInput = {
    id?: string
  }

  export type MethodExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type MethodExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type StatusPhotoCreateInput = {
    id?: string
  }

  export type StatusPhotoUncheckedCreateInput = {
    id?: string
  }

  export type StatusPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type StatusPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type StatusPhotoCreateManyInput = {
    id?: string
  }

  export type StatusPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type StatusPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TargetCreateInput = {
    id?: string
  }

  export type TargetUncheckedCreateInput = {
    id?: string
  }

  export type TargetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TargetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TargetCreateManyInput = {
    id?: string
  }

  export type TargetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TargetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TrainingCreateInput = {
    id?: string
  }

  export type TrainingUncheckedCreateInput = {
    id?: string
  }

  export type TrainingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TrainingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TrainingCreateManyInput = {
    id?: string
  }

  export type TrainingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TrainingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TrainingEvolutionCreateInput = {
    id?: string
  }

  export type TrainingEvolutionUncheckedCreateInput = {
    id?: string
  }

  export type TrainingEvolutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TrainingEvolutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TrainingEvolutionCreateManyInput = {
    id?: string
  }

  export type TrainingEvolutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TrainingEvolutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type AnamnesisCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AnamnesisMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AnamnesisMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AthleteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    sex?: SortOrder
    observation?: SortOrder
    birthDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AthleteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    sex?: SortOrder
    observation?: SortOrder
    birthDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AthleteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    sex?: SortOrder
    observation?: SortOrder
    birthDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TrainerCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TrainerMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TrainerMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BodyValuationCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BodyValuationMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BodyValuationMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FlexEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FlexEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FlexEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MethodExerciseCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MethodExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MethodExerciseMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StatusPhotoCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StatusPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StatusPhotoMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TargetCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TargetMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TargetMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TrainingCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TrainingMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TrainingMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TrainingEvolutionCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TrainingEvolutionMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TrainingEvolutionMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AnamnesisDefaultArgs instead
     */
    export type AnamnesisArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AnamnesisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AthleteDefaultArgs instead
     */
    export type AthleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AthleteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressDefaultArgs instead
     */
    export type AddressArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AddressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainerDefaultArgs instead
     */
    export type TrainerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TrainerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BodyValuationDefaultArgs instead
     */
    export type BodyValuationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = BodyValuationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseDefaultArgs instead
     */
    export type ExerciseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ExerciseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlexEvaluationDefaultArgs instead
     */
    export type FlexEvaluationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = FlexEvaluationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MethodExerciseDefaultArgs instead
     */
    export type MethodExerciseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = MethodExerciseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StatusPhotoDefaultArgs instead
     */
    export type StatusPhotoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = StatusPhotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TargetDefaultArgs instead
     */
    export type TargetArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TargetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingDefaultArgs instead
     */
    export type TrainingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TrainingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingEvolutionDefaultArgs instead
     */
    export type TrainingEvolutionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TrainingEvolutionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}